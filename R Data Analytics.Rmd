---
title: "R Data Analytics"
output: html_document
date: "2024-10-24"
---

Putri's learning on DATAQUEST


Materials and Practice
Project: Install RStudio
6 of 11 · Installing Tidyverse Packages Collection

Tidyverse is a collection of packages needed for data analysis.
These are the most common packages:
```{r}
readr #for data import.
ggplot2 #for data visualization.
dplyr #for data manipulation.
tidyr #for data cleaning.
purrr #for functional programming.
tibble #for tibbles, a modern re-imagining of dataframes.
stringr #for strings.

# install tidyverse
install.packages("tidyverse")

library(readr)
library(ggplot2)

# it's also possible to load them all using:
library(tidyverse)

```

7 of 11 · Importing Data
Learn
When we write code to import a dataset into RStudio, we must make sure that we have the working directory set to the location where our data files are stored. Otherwise, we'll have to specify the file location.

There are a few ways to set the working directory in RStudio.

Use the setwd() function. We can use this function to set our working directory to the Desktop folder by typing: setwd("~/Desktop") in the Console.

Navigate to and choose the working directory from the Session menu.

To print our working directory in the Console, type getwd().

In other lessons, we learned we'll often want to import data into R. We learned to use the read_csv() function in the readr package to import data and assign the dataframe to a variable. Datasets we import into R as dataframes display in the Environment tab as well. To demonstrate this, you can download a dataset. We will use it in the following screens.

Make sure to download this dataset and store it in your working directory.

As an alternative to typing code in the Console, we can import datasets into RStudio using the Import Dataset feature in the Environment tab.

We recommend using the readr option, which uses functions, like read_csv(), that we learned about earlier in this course.

If we import data into R using the Import Dataset feature, the data automatically displays in a tab located on the top-left of the interface.

If we import our data into R by typing functions like read_csv() in the Console, R does not automatically open the data file. To display our data, we use the function View(). For example, to look at the dataframe we created in a previous lesson when we imported data on Monster Jobs into R, we would type the following code into the Console:
```{r}
View(monster_jobs)
```

8 of 11 · Writing Scripts
In RStudio, we can write scripts in the text editor window at the top left of the interface. To create a new script, use the create new script drop down menu at the top right of the interface or commands in the file menu. You can also use the keyboard shortcut Ctrl + Shift + N for windows and Command + Shift + N for macOS.
```{r}
# loading packages
library(readr)
library(ggplot2)

# loading the monster_jobs dataset
monster_jobs_clean <- read_csv("monster_jobs_clean.csv")
view(monster_jobs_clean)

# plotting job_id vs salary_min
ggplot(data = monster_jobs_clean, aes(x = job_id, y = salary_min, color = job_type)) + geom_point() + labs(tittle = "Job ID vs Minimum Salary", x = "Job ID", y = "Minimum Salary", color = "Job Type")
```
To run a line of code we typed into our console's script, we place the cursor on the line and then, we can either click run at the top right of the script or use the following keyboard commands:

OS X: Cmd + Enter
Windows and Linux: Ctrl + Enter

We can also highlight multi-line chunks of our code that we want to run.

Sometimes, we'll write a script we want to run all at once. To highlight all the code in our script, we can use the command:

OS X: Cmd + a
Windows and Linux: Ctrl + a

When writing a script, it's good practice to begin at the top by writing code to load the packages we'll need to run the script:

```{r}
library(readr)
library(ggplot2)
```


Vectors in R
1 of 11 · Introduction to Data Structures: Generating Vectors

Learn
Understanding data structures is fundamental in R programming. They are the tools that help us store and work with data efficiently.

In this course we will learn the following data structures:

Vector: A one-dimensional container for storing values of SAME TYPE.
Matrix: A two-dimensional structure for storing values of SAME TYPE.
Lists: A versatile multi-dimensional stucture for storing values of ANY DATA TYPE/OBJECT.
Dataframe: Another two-dimensional structure for storing values of ANY DATA TYPE/OBJECT.
Here's a visual representation to help you picture these structures:


Learning about data structures involves:
- Creating them.
- Accessing their elements (indexing).
- Adding or removing elements.
- Using them in various operations and tasks.
In this lesson, we will focus on vectors. We'll build on the skills we learned in the previous course as we dive deeper into creating, manipulating, and performing calculations with vectors.

So, what is a vector? It is a data structure that holds a collection of values of the same type, allowing us to perform operations on them collectively. Think of it like an array in other languages like Python.

In the previous course, we encountered basic data types like logical, numeric (integer and double), and character. In this lesson, we will create vectors for each of these types:
- Logical vector.
- Integer vector.
- Double vector.
- Character vector.

Creating vectors is straightforward. We can generate a sequence of values in different ways:

A range of values like 1, 2, 3, and 4, can be generated as a vector using a colon (:) in R.

```{r}
a_range_vector <- 1:4
```
A sequence of values based on specific rules, such as 2, 5, and 8, can be generated using the seq() function:

```{r}
seq_2_10 <- seq(from = 2, to = 10, by = 3)
print(seq_2_10)
```
We can also repeat a value a specified number of times (times) with the rep() function:

```{r}
rep_4 <- rep(5, times = 4)
print(rep_4)
```

Plus, the rep() function can even repeat an entire vector:
```{r}
rep_6 <- rep(1:3, times = 2)
print(rep_6)
```


```{r}
vector_1 <- rep(4, times = 10)
vector_2 <- 1:12
vector_3 <- seq(from = 2.0, to = 5.50, by = 0.25)
```
2 of 11 · Creating a Vector Using Known Values
Learn
On this screen, we learn how to create a vector using known values.

A vector is created using the function c()(which stands for concatenate). This function receives a sequence of values of the SAME TYPE separated by commas (,) and it will transform them into a vector. Here are some practical examples:

A logical vector for making validation decisions in classes:
```{r}
c(TRUE, FALSE, FALSE)
c(TRUE, FALSE, TRUE, FALSE)
```

An integer vector that contains the scores of a game:
```{r}
c(12L, 3L, 24L, 8L)
c(21L, 13L)
```

A double vector that contains the selling prices of products:
```{r}
c(12.10, 24.90, 4.99)
c(21.10, 25.50, 35.50)
```

A character vector that contains names of the days of the week:
```{r}
c("Monday", "Tuesday", "Wednesday","Thursday", "Friday", "Saturday","Sunday")
c("Haruto", "Junkyu", "Asahi", "Doyoung", "Yoshi", "Jihoon")
```

Remember that R follows specific syntax rules in order for the computer to perform our instructions. If we try to store a sequence of values without the c() function:
```{r}
# selling_prices <- 12.10, 24.90, 4.99
```
We will recieve the following error message

Practice:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```


3 of 11 · Indexing Vectors by Position
Learn
On this screen, we'll investigate how a vector is structured and how we can index (i.e. access) an element in a vector.

Recall the vectors we created on the previous exercise:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

When you store these vectors in R, each value within them is assigned a position number (called an index) in memory. These positions allow us to access individual values within the vector. R follows a 1-indexed system, meaning the first element in a vector has a position of one.

To extract values from the vector, we specify their position within square brackets ([]). For example, to retrieve the value in the third position of math_grades, we can write:
```{r}
math_grades[3]
```
which returns:
```{r}
# output: [1] 85
```
We can also extract multiple values of a vector by specifying a range of positions using a colon (:). To select the first through fourth elements of the exam_grades vector, we would write:
```{r}
exam_grades[1:4]
# output: [1] 92 90 84 95
```
What if we want to select vector elements that are not next to each other? To do so, we can create a new vector of the desired indices and use this new vector of indices to extract the desired values from the original vector. To select elements in the first, third, and seventh positions of the exam_grades vector, we would write:
```{r}
exam_grades[c(1, 3, 7)]
# output: [1] 92 84 85
```

Practice:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
# Add your code below
math_exam_grade <- math_grades[1]
desired_exam_grades <- exam_grades[c(2, 3, 6)]
non_stem_exam_grades <- exam_grades[3:7]
```

4 of 11 · Indexing Vectors using Logicals
Learn
On the previous screen, we learned how to index element in a vector based on the vector structure.

Here are the vectors we created in the previous exercise.
```{r}
math_exam_grade <- math_grades[1] # extracting a single element
non_stem_exam_grades <- exam_grades[c(3:7)] # extracting a range of elements
desired_exam_grades <- exam_grades[c(2, 3, 6)]  # extracting a list of desired elements
```

Let's extract the grades of STEM classes from the exam_grades vector. To guide us, the is_stem_classes vector contains the following values:
```{r}
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

Based on what we have learned so far, we can create a vector of indices where is_stem_classes is TRUE and use it to extract the desired values.
```{r}
exam_grades[c(1, 2)]
# output: [1] 92 90
```

However, this approach is not scalable, especially with larger vectors where identifying every TRUE value would be cumbersome. Luckily, R offers a more elegant solution: logical indexing. Thus, to extract the grades of STEM classes using the is_stem_classes vector, we can do:
```{r}
exam_grades[is_stem_classes]
# output: [1] 92 90
```

Practice:
```{r}
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
# Add your code below
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
preferred_homework_grades <- homework_grades[is_stem_classes]
```

Vectors in R
5 of 11 · Modifying Elements in a Vector
Learn
On the two previous screens, we learned how to extract elements from a vector using various methods.

- To extract a single element: math_grades[1].
- For a range of elements: exam_grades[c(3:7)].
- To select specific elements using an integer vector of indices: exam_grades[c(2, 3, 6)].
- For filtering elements based on a logical vector: exam_grades[is_stem_classes].

On this screen, we'll learn how to modify the elements of a vector. Luckily, we can achieve this by using two notions that we have already learned: assignment with <- and indexing.
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
```

To replace the third grade in math_grades by 90L, we can write:
```{r}
math_grades[3] <- 90L #modify the third element of the vector
print(math_grades) 
# output: [1] 92 87 90
```

We can see that the third value has changed. Here's how R handles it:

First, it identifies the element we would like to modify using its index.
Then, it updates that specific element with the new value.
We can therefore make similar modifications using the other indexing methods.

Using a vector of indices:
```{r}
exam_grades[c(3:7)] <- 85
print(exam_grades)
# output: [1] 92 90 85 85 85 85 85
```

Using logicals
```{r}
exam_grades[is_stem_class] <- 95 
print(exam_grades) 
# output: [1] 95 95 84 95 77 92 85
```

Practice:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)

math_grades[2] <- 80L
exam_grades[is_stem_classes] <- 92
```

6 of 11 · Appending Elements to a Vector
Learn
It turns out that there are three additional class grades that we didn't initially consider in our dataset.

The exam_grades vector contains the following values.
```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
```

The three additional exams' grades are stored in the vector extra_exam_grades.
```{r}
extra_exam_grades <- c(75, 85, 95)
```

To add these three values to the existing vector we can manually add these three elements.
```{r}
new_exam_grades <- c(92, 90, 84, 95, 77, 92, 85, 75, 85, 95)
```

However, this approach can become quite cumbersome, especially with larger vectors. Fortunately, R provides an efficient solution using the c() function:
```{r}
new_exam_grades <- c(exam_grades, extra_exam_grades)
print(new_exam_grades)
# output: [1] 92 90 84 95 77 92 85 75 85 95
```

This code creates a new vector, new_exam_grades, by appending the elements in extra_exam_grades to the vector exam_grades.

We can also reverse this process by appending the elements in exam_grades to the vector extra_exam_grades by swapping their positions like this:
```{r}
new_exam_grades <- c(extra_exam_grades,exam_grades)
print(new_exam_grades) 
# output: [1] 75 85 95 92 90 84 95 77 92 85
```

practice:
```{r}
extra_is_stem_classes <- c(TRUE, FALSE, FALSE)
new_is_stem_classes_end <- c(is_stem_classes, extra_is_stem_classes)
new_is_stem_classes_start <- c(extra_is_stem_classes, is_stem_classes)
```


7 of 11 · Removing Elements from a Vector
Learn
On this screen, we'll investigate how to remove elements from a vector by applying negative indexing. First, let's recall the content of the math_grades and exam_grades vectors.
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
```

To remove a value from the vector, we specify their positions preceded by a minus symbol (-) within square brackets ([]). To remove the value in the third position of math_grades, we can write:
```{r}
math_grades[-3]
#output: [1] 92 87
```

With negative indexing, we've removed the element in the third position. We can also remove multiple values from a vector by creating a vector of indices to exclude preceded by a minus symbol (-). To remove elements in the first, third, and seventh positions from the exam_grades vector, we would write:
```{r}
exam_grades[-c(1, 3, 7)]
#output: [1] 90 95 77 92
```

practice
```{r}
math_without_exam_grades <- math_grades[-1]
above_90_exam_grades <- exam_grades[-c(3, 5, 7)]
```



8 of 11 · Performing Operations with Vectors
Learn
We learned to perform operations on single values/variables in the previous course. It is also possible to perform the same operations with vectors. In the later case, element-wise operations are performed. Element-wise operation means to perform operations on every element of multiple vectors at once. This is a very powerful feature of R.
We can start by creating three vectors, one for each assignment category, to work with:
```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)
```

If we are interested in calculating the final scores for each class, we could calculate each class grade individually:
```{r}
math <- (92 + 87 + 85) /3
chemistry <- (90 + 81 + 92)/3 # and so on.
```

However, as we work with larger datasets in R, this manual appraoch becomes impractical. Instead of calculating each final grade individually, we can use vector arithmetic to perform these calculations.

In vector arithmetic, operations are performed between values in the same position of two vectors. For example, let's add Johnny's exam_grades and homework_grades vectors and save the output as a new vector called sum_grades:
```{r}
sum_grades <- exam_grades + homework_grades
```

practice: 
```{r}
class_scores_sum <- exam_grades + homework_grades + project_grades
class_scores_avg <- class_scores_sum / 3
```


9 of 11 · Vector Recycling
Learn
In the previous example, we calculated class scores by performing vector arithmetic. In that scenario, the three vectors we're working with were of the same length. Each had seven values for the seven classes. This isn't always the case, though. For example, what if a grade is missing, like the last homework grade?

When the length of two vectors don't match, R employs a feature called recyclying (or repetition), in order to make them compatible. Here, the shorter vector is recycled until it matches the length of the longer one.

To show how R's recycling behavior works when we perform operations on vectors of different lengths, let's shorten our homework vector to only six values:

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90)
```

Let's now add the vectors exam_grades and homework_grades.
The R interpreter determines that the homework_grades vector is shorter than the exam_grades vector and automatically recycles the values in the homework_grades vector until the two vectors are the same length. 

Once the vector lengths match, the R interpreter performs the specified arithmetic operation.

When we perform operations on vectors of unequal lengths in R, we receive the following warning message:
```{r}
# Warning message in exam_grades + homework_grades:
# “longer object length is not a multiple of shorter object length”
```

R still performs the calculation. The warning message alerts us to the possibility that the different vector lengths were not intended.

Typically, vector recycling is an interesting feature in R, but should always be used wisely.
- It can be very useful in operations where repetition is natural. For example, with timed data. If we have a vector with 30 days of data (vector_30_days) that we want to sum with a vector of 7 days of data, i.e, data for a week (vector_week), recycling can work well and yield the right result: vector_30_days + vector_week.

- It can also be misleading if the repetition is not desirable. On this screen's example, it may be inappropriate to consider the grade of the first two classes as grades of missing classes.

Scenario of writing programs to calculate the average scores for each class when some grades are missing.

practice:
```{r}
exam_grades <- c(92, 90, 84)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)
# Add your code below
class_scores_sum_recycled <- exam_grades + homework_grades + project_grades
class_scores_avg_recycled <- class_scores_sum_recycled / 3
```


10 of 11 · Vectors Using Names
Learn
Previously, we had learned that in the structure of a vector, each element in a vector is indexed by a number that represents the position of that element. We can also manipulate and access elements of a vector using names, instead of positions.

As we illustrate how it works, let's consider our running dataset again.
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

Is there a way to manipulate the names of these values instead of their positions? For example, in the vector math_grades, we would like to identify the first element as the Exams grade, the second as Homework grade and the last as the Projects grade.

We can achieve this by specifying the name of each value using the equal (=) when creating the vector.
```{r}
math_grades <- c("Exams"=92L, "Homework"=87L, "Projects"=85L)
# output:
# Exams Homework Projects 
#  92       87       85
```

When the set of names already exists as a vector we can also achieve this by using the names() function.
```{r}
grade_names <- c("Exams", "Homework", "Projects")
math_grades <- c(92L, 87L, 85L)
names(math_grades) <- grade_names
# output: 
# Exams Homework Projects 
#   92       87       85
```

Fortunately, all indexing methods we learned can be applied using names also. For example, to get the first element ("Exams") and the last element ("Projects") of the math_grades vector, we write:
```{r}
math_grades[c("Exams", "Projects")]
# output: 
# Exams Projects 
#   92       85
```

We can replace these values with another one.
```{r}
math_grades[c("Exams", "Projects")] <- 80L
# output: Exams Homework Projects 
#          80       87       80
```

If we call the names() function in a vector without assigned names, the function returns the names' vector or NULL if there is no name.

practice:
```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)

class_names <- c("math", "chemistry", "writing", "art", "history", "music", "physical_education")
# Add code
names(exam_grades) <- class_names
names(homework_grades) <- class_names
names(project_grades) <- class_names
```

11 of 11 · Next Steps
In this lesson, we've learned fundamental skills on how to create, manipulate, add attributes to, index, and perform calculations using vectors. Vectors are a key data structure in R, and the knowledge gained in this lesson forms the basis for more complex data analysis.

In the next lesson, we'll dig deeper into analysis as we work with real-world data on university rankings. Now that we've learned the basics of working with vectors, we'll expand our R capabilities as we work with two-dimensional data structure: matrices.



Matrices in R
1 of 11 · Creating Matrices by Restructuring Vectors
Learn
In this lesson, we'll learn how to create matrices by restructuring vectors using the matrix() function. Understanding matrices is a very crucial skill for effective data manipulation and analysis in R. The good news is that we'll be reusing the skills from the vector lesson as we dive deeper into creating, manipulating, and performing calculations with matrices.

A matrix is a two-dimensional data structure used to store values of the same data type. Similar to vectors, matrices can be of type logical, numeric (integer and double), and character. Unlike vectors (one-dimension) that can be indifferently considered as a column or a row, matrices are two-dimensional, which introduces the concepts of rows and columns.

As we learned in the vectors' lesson, learning to work with data structures is critical for programming in R, because efficient data storage and operations rely on them. Remember that there are four data structures that will be covered in this course.

One way to create a matrix is by restructuring a vector into a matrix using the matrix() function. This restructuring can be done in two ways: by column (the default) or by row. The function receives the vector to restructure into a matrix, and the number of rows (nrow) and columns (ncol).

To demonstrate this default column way, let's restructure a vector without specifying ncol parameter:
```{r}
mat_3x2_bycol <- matrix(1:6, nrow = 3)
print(mat_3x2_bycol)
# output:
# _    [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6
```

Now, let's specify the ncol parameter:
```{r}
mat_3x2_bycol <- matrix(1:6, nrow = 3, ncol = 2)
print(mat_3x2_bycol)
# output:
# _    [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6

# We get the same result
```

If we want to restructure the vector by row, we have to set the byrow parameter to TRUE in the matrix() function.
```{r}
mat_3x2_byrow <- matrix(1:6, nrow = 3, ncol = 2, byrow = TRUE)
print(mat_3x2_byrow)
# output:
# _    [,1] [,2]
# [1,]    1    2
# [2,]    3    4
# [3,]    5    6

# byrow = TRUE indicates that the vector should be filled in by row
# If byrow = FALSE (which is the default), the vector would be filled in by column.
```

We can also provide either nrow or ncol in the matrix() function and R will automatically deduce the missing parameter by dividing the length of the vector by the provided parameter.
```{r}
# automatic determination of columns
matrix(1:6, nrow = 3) # equivalent to ncol: 6 / nrow = 2
# automatic determination of rows
matrix(1:6, ncol = 2) # equivalent to nrow: 6 / ncol = 3
```

Of course, we can use the matrix() function to restructure any kind of vector into a matrix. Here are other examples.

A logical matrix that decides which classes are validated or not for two students (each row represents a student):
```{r}
is_validated <- c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)
mat_is_validated <- matrix(is_validated, nrow = 2)
print(mat_is_validated)
# output: 
# _     [,1]  [,2] [,3]
# [1,]  TRUE FALSE TRUE
# [2,] FALSE  TRUE TRUE
```

An integer matrix that contains a sequence of values from 2 to 11 by 3 restructured into a matrix of two columns and rows.
```{r}
matrix(seq(from = 2, to = 11, by = 3), nrow = 2, ncol = 2)
# we use the seq() function to create our sequence of values and we don't store the result in a variable

# output:
# _    [,1] [,2]
# [1,]    2    8
# [2,]    5   11
```

A character matrix that contains names of the days of a week:
```{r}
days_names <- c("Wed", "Thu", "Fri", "Sat", "Sun", "Mon", "Tue")
vector_month_days <- rep(day_names, 4)
matrix_month_days <- matrix(vector_month_days, nrow = 4, ncol = 7, byrow = TRUE)
print(matrix_month_days)
# output:
# _    [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7] 
# [1,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
# [2,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
# [3,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
# [4,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
```

practice:
```{r}
vector_1 <- c(1, 4, 5, 9) # [1] 1 4 5 9
vector_2 <- 1:12 # [1] 1  2  .. 11 12
vector_3 <- seq(from = 2.0, to = 5.50, by = 0.25) # [1] 2.00 2.25 .. 5.25 5.50
# Add code
matrix_1 <- matrix(vector_1, nrow = 2, ncol = 2)
matrix_2 <- matrix(vector_2, nrow = 4, ncol = 3)
matrix_3 <- matrix(vector_3, nrow = 3, ncol = 5, byrow = TRUE)
```


2 of 11 · Creating a Matrix by Combining Vectors
Learn
On the previous screen, we learned how to create a matrix by restructuring a vector using the matrix() function. On this screen, we will learn how to create a matrix by combining vectors.


Combining vectors into matrices is straightforward because of similarities in the two data structures. Both consist of a single data type (here, numeric). 

To combine the vectors into a matrix, we can use the rbind() function. The "r" in rbind() stands for rows — this function allows us to combine multiple vectors by row. 

To demonstrate this, let's combine the universities vectors using rbind():
```{r}
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)

university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)
print(university_matrix)
# output:
# _         [,1] [,2] [,3] [,4] [,5]
# harvard      1    1    1    1    3
# stanford     2    9    3    4   10
# MIT          3    3    2    2    1
# cambridge    4    2    6   13   48
# oxford       5    7   12    9   15
# columbia     6   13   13   12    4
```

To combine vectors into a matrix, remember we can also use the function cbind(). The "c" in cbind() stands for columns — this function also allows us to combine multiple vectors, but, by column.

practice:
```{r}
world_rank <- c(1, 2, 3, 4, 5, 6)
quality_of_education <- c(1, 9, 3, 2, 7, 13)
influence <- c(1, 3, 2, 6, 12, 13)
broad_impact <- c(1, 4, 2, 13, 9, 12)
patents <- c(3, 10, 1, 48, 15, 4)
# add code
university_matrix <- cbind(world_rank, quality_of_education, influence, broad_impact, patents)
```



3 of 11 · Naming Matrix Rows and Columns

When we use the rbind() function to create a matrix from vectors with name attributes, the vector names are retained as row name attributes. However, our columns don't have any name attributes associated with them. Adding names to rows or columns of a matrix is similar to naming elements of a vector.

Keep in mind that attributes are different from elements of vectors or matrices — they are not stored in these data structures, and you cannot perform operations on them. Attributes make interpreting the contents of vectors and matrices easier.

In the previous lesson, we learned to add name attributes to vectors using the attribute accessor function names(). Since matrices have both rows and columns, there are separate functions for adding name attributes to each:

Rows: rownames()

Columns: colnames()

We already have university names for rows of university_matrix, but we need to add column names so that we can see the categories for each university's ranking.

Let's name the columns in the university_matrix we created in an earlier example:
```{r}
university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)
colnames(university_matrix) <- c("world_rank", "quality_of_education", "influence", "broad_impact", "patents")
```

If we inspect university_matrix by printing it, we can see the columns are named:
```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```

Naming rows using rownames() uses the same syntax.

As with vectors, if we call the rownames() or colnames() functions in a matrix without assigned names, the function will return the names of rows or columns, or NULL if there is no name.

practice:
```{r}
rownames(university_matrix) <- c("harvard", "stanford", "MIT", "cambridge", "oxford", "columbia")
# output:
# _         world_rank quality_of_education influence broad_impact patents 
# harvard     1           1                   1         1           3 
# stanford    2           9                   3         4           10 
# MIT         3           3                   2         2           1 
# cambridge   4           2                   6         13          48 
# oxford      5           7                   12        9           15 
# columbia    6           13                  13        12          4
```


4 of 11 · Indexing Matrices by Columns and Rows
Learn
Earlier in this course, we learned how to index (i.e., access) vectors, in order to extract specific elements. We can also index matrices. Since matrices are two-dimensional objects, we can index to select:
a specific value
matrix[row, column]

a specific row
matrix[row_index,]

a specific column
matrix[, column_index]


The syntax for indexing matrices is similar to that for indexing vectors. We can extract values from the matrix by specifying the row and/or column positions in square brackets ([]) separated by comma(,).

Let's use the university_matrix to illustrate how to index a matrix.
```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```


To return the value in the third row (representing MIT) and second column (corresponding to quality_of_education) of university_matrix, we can write:
```{r}
university_matrix[3, 2] # number indexing
# output: 
# [1] 3
```

We can also use the row name ("MIT") and the column name ("quality_of_education""):
```{r}
university_matrix["MIT", "quality_of_education"] # name indexing
# output:
# [1] 3
```

To return all the values in the third row (MIT) of university_matrix only, we can write:
```{r}
university_matrix[3, ] # we left the column's place empty after comma

# which returns a named vector:
# output:
# world_rank quality_of_education   influence   broad_impact   patents 
#         3                    3           2              2         1
```

We can also use the row name ("MIT"):
```{r}
university_matrix["MIT", ] #we left the column's place empty after the comma
# which returns a named vector:
# output:
# world_rank quality_of_education   influence   broad_impact   patents 
#         3                    3           2              2         1
```

To return all the values in the second column (quality_of_education) of university_matrix only, we can write:
```{r}
university_matrix[ , 2] # we left the column's place empty before the comma
# output:
# harvard  stanford    MIT cambridge    oxford  columbia 
#     1         9      3         2         7        13
```

We can also use the column name ("quality_of_education"):
```{r}
university_matrix[ , "quality_of_education"] #we left the row's place empty before the comma
# output:
# harvard  stanford   MIT cambridge    oxford  columbia 
#      1         9     3         2         7        13
```

practice:
```{r}
cell_columbia_influence <- university_matrix["columbia", "influence"]
vector_cambridge <- university_matrix["cambridge", ]
vector_world_rank <- university_matrix[ ,"world_rank"]
```



5 of 11 · Indexing Matrices using Vectors
Learn
recap

The syntax for indexing a matrix is matrix[row, column]. In the square brackets ([]), we indicate the row index first, then the column index and both are separated by a comma (,).
We can index (i.e., access) a specific value by indicating its row and its column: matrix[row, column].
We can index (i.e., access) a specific row by indicating the row index/name, leaving the column's place empty in the square bracket: matrix[row, ].
We can index (i.e., access) a specific column by indicating the column index/name, leaving the row's place empty in the square bracket: matrix[ , column].
Meanwhile, in the previous lesson, we learned that a vector can also be indexed by another vector. The indexing vector can be:
- a range of integer values,
- an integer vector of indices,
- a logical vector, or
- a character vector of names.
We can also index matrices the same way.

```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```

To return the values in the first three rows (harvard, stanford, and MIT) and the second column (quality_of_education) of university_matrix, we can write:
```{r}
university_matrix_[1:3, 2]
# output:
# harvard stanford  MIT 
#      1        9    3
```

We can also use the rows and columns names:
```{r}
university_matrix[c("harvard", "stanford", "MIT"), "quality_of_education"]
# output: 
# harvard stanford  MIT 
#      1        9    3
```

To return the rankings for the USA's universities (i.e., Harvard, Stanford, MIT, and Columbia):
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE) # e.g. the first TRUE means Harvard is an American university.
university_matrix[usa_universities, ] # notice the absence of the column index
# output:
# _        world_rank quality_of_education influence broad_impact patents
# harvard           1                    1         1            1       3
# stanford          2                    9         3            4      10
# MIT               3                    3         2            2       1
# columbia          6                   13        13           12       4
```

To return the rankings for the USA's universities (i.e., Harvard, Stanford, MIT, and Columbia) in the influence, broad impact, and patents categories:
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
university_matrix[usa_universities, c(3, 4, 5)] #instead of c(3, 4, 5) we can use 3:5 or the names of the columns
# output:
# _        influence broad_impact patents
# harvard          1            1       3
# stanford         3            4      10
# MIT              2            2       1
# columbia        13           12       4
```

practice:
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
# add code
sub_matrix <- university_matrix[c("harvard", "MIT", "cambridge"), c("world_rank", "broad_impact")]
usa_universities_rankings <- university_matrix[usa_universities, c("world_rank", "patents")]
```


6 of 11 · Modifying Elements in a Matrix
Learn
In this screen, we learn how to modify the elements of a matrix. Luckily, we can achieve this by applying two concepts that we have already learned: assignment using <- and indexing.

matrix sample:
```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```

To replace the value in the third row (MIT) and second column (quality_of_education) of university_matrix by 2, we can write:
```{r}
university_matrix[3, 2] <- 2 
# modify the element at the third row and second column
```

We can see that the element in the third row and the second column has changed. Actually, R first located the element that we would like to modify (by indexing) and then modified its content by assigning the new value to it.

We can, therefore, make similar modifications using the other indexing methods.
```{r}
university_matrix[usa_universities, 3:5] <- 1
```

practice:
```{r}
university_matrix <- cbind(world_rank, quality_of_education, influence, broad_impact, patents)
rownames(university_matrix) <- c("harvard", "stanford", "MIT", "cambridge", "oxford", "columbia")

usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)

# add code
university_matrix[4, 5] <- 3
university_matrix[c(1, 2, 3, 6), ] <- 2
```


7 of 11 · Appending Elements To a Matrix
Learn
Let's return to our initial goal: Deciding which university to attend. As we look at our data, we notice that while we have information to help us assess the quality of education and impact of the six universities, we also would like to have information on the cost of tuition for each university.

To address this, we've done some research and gathered data on annual tuition, in U.S. dollars, for each university:
Harvard $43,280
Stanford $45,000
MIT $45,016
Cambridge $49,350
Oxford $28,450
Columbia $55,161

Now, our plan is to add this tuition data to our matrix so that we can proceed with analyzing the data to enable us make an informed decision on our university choice.

First, let's create a vector containing the tuition data:
```{r}
tuition <- c(43280, 45000, 45016, 49350, 28450, 55161)
```

Next, we need to add the tuition vector to university_matrix as a column.

If we want to add the vector tuition as a new column to the university_matrix matrix, its length should be equal to the number of rows in university_matrix.

Earlier in this lesson, we used the rbind() function to combine the university rankings vectors into a single matrix. The rbind() function combines vectors or matrices by row. To add a vector to a matrix as a column or to join two matrices together by column, we used the cbind() function. This means that the cbind() function combines vectors or matrices by column.

To add the vector tuition as a new column to the university_matrix matrix, we can use the cbind() function.
```{r}
cbind(university_matrix, tuition)
# output:
# _         world_rank quality_of_education influence broad_impact patents tuition
# harvard            1                    1         1            1       3   43280
# stanford           2                    9         3            4      10   45000
# MIT                3                    3         2            2       1   45016
# cambridge          4                    2         6           13      48   49350
# oxford             5                    7        12            9      15   28450
# columbia           6                   13        13           12       4   55161

  
```

Note: If the matrix does not display correctly, adjust the vertical separator between the learning session and the editor.
The functions rbind() and cbind are similar in terms of syntax. To practice, let's add the rankings for the University of California, Berkeley, as a new row to the university_matrix using the rbind() function.

practice:
```{r}
california <- c(7, 5, 4, 7, 29, 43176)
# add code
complete_university_matrix <- rbind(university_matrix, california)
```


8 of 11 · Removing Elements from a Matrix
Learn
In this screen, we'll investigate how to remove elements from a matrix. To remove elements from a matrix, we use negative row/column index. Before explaining this, let's recall the content of the complete_university_matrix.
```{r}
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# stanford            2                    9         3            4      10   45000
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
# california          7                    5         4            7      29   43176
```

We can remove values from the matrix by specifying their row and column preceded by a minus symbol (-) in square brackets ([]). To remove the second row of complete_university_matrix, we can write:
```{r}
complete_university_matrix[-2, ]
# output:
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
# california          7                    5         4            7      29   43176
```

To remove the second and third columns from the USA universities, we can write:
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)
complete_university_matrix[usa_universities, c(-2, -3)]
# output:
# _          world_rank broad_impact patents tuition
# harvard             1            1       3   43280
# stanford            2            4      10   45000
# MIT                 3            2       1   45016
# columbia            6           12       4   55161
# california          7            7      29   43176
```

To remove the second, third and fourth columns from complete_university_matrix where the tuition is greater than or equal to 45000, we can write:
```{r}
complete_university_matrix[tuition >= 45000, c(-2, -3, -4)]
# output:
# _         world_rank patents tuition
# stanford           2      10   45000
# MIT                3       1   45016
# cambridge          4      48   49350
# columbia           6       4   55161
```

practice:
```{r}
university_matrix_wtho_first <- complete_university_matrix[ , -1]
below_10_university_matrix <- complete_university_matrix[broad_impact <= 10, c(-2, -5)]
```


9 of 11 · Performing Operations with Matrices
Learn
We learned to perform operations on single values/variables in the previous course. The same operations can also be performed with matrices. In the latter case, element-wise operations are performed. Element-wise operation means to perform operations on every element of a matrice at once. This is a very powerful feature of R.

As we illustrate how this works, let's consider our running dataset, complete_university_matrix.
```{r}
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# stanford            2                    9         3            4      10   45000
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
# california          7                    5         4            7      29   43176
```

Let's say we want to calculate an aggregate ranking for each university. One way to do this is by calculating the sum of their rankings in every category and we can use the function sum() for this purpose. We use indexing to specify the university row we want to calculate a score for and then, also use negative indexing to remove the sixth column (tuition) which is not a ranking, like this:
```{r}
sum(complete_university_matrix["harvard", -6])
sum(complete_university_matrix["stanford", -6])
sum(complete_university_matrix["MIT", -6])
# output:
# [1] 7 
# [1] 28
# [1] 11
```

However, we're learning to use R with larger datasets. Instead of calculating each university score, we can use the function rowSums() to perform these calculations. Hence, it won't be necessary to specify the row name.
```{r}
row_Sums(complete_university_matrix[ , -6])
#output:
# harvard   stanford    MIT  cambridge   oxford   columbia california 
#      7         28     11         73       48         48         52
```

We can also use the function colSums() to compute an aggregate ranking for each category summing rankings for every university.
```{r}
colSums(complete_university_matrix[ , -6])
# output:
# world_rank quality_of_education  influence   broad_impact   patents         
#       28                   40         41             48       110
```

In addition to functions sum(), rowSums(), and colSums(), R provides the mean(), rowMeans(), and colMeans() functions for calculating average scores, which have a similar syntax as the functions we've just learned. These functions are available when you need to compute average values from your matrices.

practice:
```{r}
harvard_scores_avg <- mean(complete_university_matrix[ 1, -6])
university_scores_avg <- rowMeans(complete_university_matrix[ , -6])
category_scores_avg <- colMeans(complete_university_matrix[ , -6])
```


10 of 11 · Scoring and Ranking Universities
Learn
Now that we've learned to combine vectors into matrices, to extract elements, and to perform operations on matrices, let's return to our initial goal: Analyzing the university ranking data to decide on a university to attend.

To answer this question, let's develop a score for each university that is an aggregate of the rankings and tuition information available in university_matrix. We'll rank the universities for each category we have data for: world_rank, quality_of_education, influence, broad_impact, patents, and tuition. These rankings will allow us to evaluate universities across various aspects.

Then, we can calculate a score for each university from the sum of its rankings.

Let's rank each university relative to others in the dataset.
```{r}
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# stanford            2                    9         3            4      10   45000
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
```

We use the rank() function, along with an expression that indexes the matrix, to specify the category we want to rank the universities by. The rank() function returns a vector of numeric values. For example, to rank universities by quality_of_education, we'd write:
```{r}
rank(university_matrix[ , "quality_of_education"])
# output:
# harvard   stanford     MIT  cambridge     oxford   columbia
#      1          5       3          2          4          6
```

We can do it for every category we have in our dataset and store the results in variables:
```{r}
world_rank_rank <- rank(university_matrix[,"world_rank"])
quality_of_education_rank <- rank(university_matrix[,"quality_of_education"])
influence_rank <- rank(university_matrix[,"influence"])
broad_impact_rank <- rank(university_matrix[,"broad_impact"])
patents_rank <- rank(university_matrix[,"patents"])
tuition_rank <- rank(university_matrix[,"tuition"])
```

Now that we've ranked the six universities by each category, let's combine the vectors containing the ranks into a single matrix (ranks_university_matrix) using rbind():
```{r}
ranks_university_matrix <- rbind(world_rank_rank, quality_of_education_rank, influence_rank, broad_impact_rank, patents_rank, tuition_rank)
```

Note that because we used rbind(), we combined the vectors by rows. The new matrix contains the vectors for each category stacked one on top of the other. Each university's rankings are in a different column.

Now, we can calculate a score for each university. Smaller scores indicate higher rankings. Let's assume that we value every category in our university selection equally.

To calculate an aggregate score for each university, let's calculate the sum of its rankings in every category using the colSums() function.
```{r}
colSums(ranks_university_matrix)
# output:
# harvard   stanford    MIT  cambridge     oxford   columbia 
#      8         20     15         27         24         32
```

practice:
```{r}
university_matrix_avg <- colMeans(ranks_university_matrix)
```
11 of 11 · Next Steps


Lists in R
1 of 10 · Lists: Objects That Can Contain Multiple Data Types

Learning a data structure implies learning:
- To create a data structure.
- To index (i.e., accessing) data structure's elements.
- To add/remove elements from a data structure.
- To use data structures in our operations/tasks.
- In the first two lessons of this course, we learned about two different data structures:

Vectors: One-dimensional data structures that hold a single data type.

Matrices: Two-dimensional data structures that hold a single data type.

In the last lesson, we worked with matrices to analyze university rankings, which helped us take decision on the topmost university for us to attend. Now that we're about to begin our first year at Harvard, we're faced with another decision on clubs (sports, art, music, etc) to join, so that we can make friends with similar interests. This is where lists come in.

In this lesson, we'll learn how to work with data stored in lists as we organize the results of our investigation of different university clubs.

A list, is a multi-dimensional data structure which contains MULTIPLE DATA TYPE of objects. The objects may consist of single data elements (literal values), different data structures like vectors, matrices, and even other lists.

Why would we want to create lists of objects in R? The answer is that storing objects in lists allows us to make use of some very powerful R features for performing the same operation on each object in our list, which can let us avoid repetitively typing the same function.

We'll learn how to harness the power of lists for performing tasks such as those illustrated above in the next course. For now, we'll proceed with providing a strong foundation in creating, manipulating, and understanding the structure of lists.

Practice:
```{r}
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)
# add code
category_names <- c("world_rank", "quality_of_education", "influence", "broad_impact", "patents")
university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia) 
colnames(university_matrix) <- category_names
```

2 of 10 · Creating a List
Learn
On this screen, we learn how to create a list.

A list is created using the list() function. This function receives a sequence of values of ANY TYPE separated by commas (,). R then takes charge of constructing a list from those values.

In the following example, we are storing three club names in a list:
```{r}
list("tennis", "films", "outdoors")
# output:
# [[1]]
# [1] "tennis"

# [[2]]
# [1] "film"

# [[3]]
# [1] "outdoors"
```

We can also use the function c() to create a vector in the example above because all the values are of the SAME TYPE.

Let's now try to create a vector with DIFFERENT TYPES.

In the following example, we are attempting to create a vector that contains the University of Harvard's name, its rankings in every category, and if it's in the USA or not.
```{r}
c("harvard", 1, 1, 1, 1, 3, TRUE)
# Not minding the different data types, this returns a character vector:
# OUTPUT:
# [1] "harvard" "1"      "1"      "1"      "1"      "3"      "TRUE"
```

We may wonder why did that last command create a character vector? Since we are trying to create a vector of different types (character + numeric + logical), which is not allowed in R, R transforms all the values into the same type following the highest type rule, that's why all the values are of the character type.

However, if we want to preserve the different data types in the same object, we need to use the list() function like so:
```{r}
list("harvard", 1, 1, 1, 1, 3, TRUE)
# output:
# [[1]]
# [1] "harvard"

# [[2]]
# [1] 1

# [[3]]
# [1] 1

# [[4]]
# [1] 1

# [[5]]
# [1] 1

# [[6]]
# [1] 3

# [[7]]
# [1] TRUE
```

We can see that R understands each type and keeps them as such in the data structure.

Let's create a list where the rankings in the previous list are stored as a vector in the list.
```{r}
list("harvard", c(1, 1, 1, 1, 3), TRUE)
# output:
# [[1]]
# [1] "harvard"

# [[2]]
# [1] 1 1 1 1 3

# [[3]]
# [1] TRUE
```

We can also name the elements in the list like when we created named vectors. To specify names we can use =: name = the_object.
```{r}
list(name = "harvard", ranking = c(1, 1, 1, 1, 3), is_in_usa = TRUE)
# OUTPUT:
# $name
# [1] "harvard"

# $ranking
# [1] 1 1 1 1 3

# $is_in_usa
# [1] TRUE
```

practice:
```{r}
university_clubs <- list("ballroom dancing", "rugby", "bird watching", "pottery")
mit_list <- list("MIT", c(3,3,2,2,1), TRUE)
mit_named_list <- list(name = "MIT", ranking = c(3,3,2,2,1), is_in_usa = TRUE)
```


3 of 10 · Anatomy of a List
Learn
Let's look at the list of clubs we created on the previous screen:
```{r}
# output:
# [[1]]
# [1] "ballroom dancing"

# [[2]]
# [1] "rugby"

# [[3]]
# [1] "bird watching"

# [[4]]
# [1] "pottery"
```

Note that each club we stored in the list appears on its own line, and its position within the list is shown in brackets above it ([[1]] through [[4]]). This indicates the order of the objects as stored in the list.

We know that the university_clubs list contains only single elements of character data type. Recall, however, that lists may contain objects of any data type. This flexible feature allows us to use them to store other information from our club search, including club descriptions, types of activities, the cost of club dues, and the times when the club holds meetings.

Here is some of the data we've gathered for the chess club:
```{r}
club_title <- c("Chess Club")
club_description <- c("Meets two nights a week for members to play chess. Snacks are provided")
club_dues <- c(50, 20, 15)
meeting_days <- c("Monday", "Wednesday")
meeting_times <- c("6:00 pm", "8:00 pm")
```

The pieces of information we have are:

Club title (a vector of character data)
Club description (a vector of character data)
Club dues (a vector of numeric data)
Meeting days (a vector of character data)
Meeting times (a vector of character data)
Let's create a list to organize and store this data.

practice:
```{r}
club_title <- c("Chess Club")
club_description <- c("Meets two nights a week for members to play chess. Snacks are provided.")
club_dues <- c(50, 20, 15)
meeting_days <- c("Monday", "Wednesday")
meeting_times <- c("6:00 pm", "8:00 pm")

# add code
club_meetings <- rbind(meeting_days, meeting_times)
chess_club <- list(club_title, club_description, club_dues, club_meetings)
```

4 of 10 · Naming Objects in a List
Learn
On this screen, we'll learn how to give names to objects within a list in R. This can make working with lists more organized and easy to understand.

We created the list chess_club on the previous screen to organize the information we gathered about the club:
```{r}
# output:
# [[1]]
# [1] "Chess Club"

# [[2]]
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# [[3]]
# [1] 50 20 15

# [[4]]
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

When you create a list in R, the individual objects within the list are not automatically assigned names, but their original data types are retained. You can then add names to the objects, as we learned before.
```{r}
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Play matches against clubs from local universities"), club_dues = c(100, 50))

# The resulting list, rugby_club, contains three objects with names assigned to them:
# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 100  50
```

However, we're learning to use R with larger datasets and this can become very cumbersome. Instead of assigning a name to each element manually, we can use a vector of character data to assign names to objects of a list. Assigning names to list objects is similar to assigning names to vector elements using the names() accessor function.

To illustrate this, let's create a list containing data for the ballroom dancing club:
```{r}
ballroom_dancing <- list(c("Ballroom Dancing"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))

# output:
# [[1]]
# [1] "Ballroom Dancing Club"

# [[2]]
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# [[3]]
# [1] 150
```

Now, let's assign a name to each object in ballroom_dancing:
```{r}
names(ballroom_dancing) <- c("club_title", "club_description", "club_dues")
# If we display ballroom_dancing, we'll see that each object is named:
# output:
# $club_title
# [1] "Ballroom Dancing Club"

# $club_description
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# $club_dues
# [1] 150
```

As with vectors and matrices, if we call the names() function in a list without assigned names, the function returns the names's vector or NULL if there is no name.

Let's assign names to objects of the chess_club list that we created earlier.

practice:
Use the names() function to assign the chess_club_names vector as names to elements of the chess_club list.
```{r}
club_meetings <- rbind(meeting_days, meeting_times)
chess_club <- list(club_title, club_description, club_dues, club_meetings)
chess_club_names <- c("club_title", "club_description", "club_dues", "club_meetings")
# Type your code below
names(chess_club) <- c("club_title", "club_description", "club_dues", "club_meetings")
```


5 of 10 · Indexing Lists: Accessing Data in Lists
Learn
In previous lessons, we learned to index vectors and matrices to extract a subset of values. Similarly, we can index lists.

Generally, we'll use two different indexing operations on lists:

Single brackets to return a list of selected elements ([])
Double brackets to return a single element ([[]])
Let's take the rugby_club list as an example:
```{r}
# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 100  50
```

If we want to extract the second object in the list, we use single brackets [] like the following code:
```{r}
rugby_club[2]
# output:
# $club_description
# [1] "Plays matches against clubs from local universities"
```

If we check the type of the object, with the function class(), we see that it is a list:
```{r}
class(rugby_club[2])
# output:
# [1] "list"
```

Let's perform this operation using double brackets:
```{r}
rugby_club[[2]]
# the output is: [1] "Plays matches against clubs from local universities"

class(rugby_club[[2]])
# the output is: [1] "character"
```

This time, the output is a single element of the data type character.

To better illustrate when we'd choose to use single or double brackets to index a list, let's extract multiple list elements.

Recall from earlier lessons that we can extract multiple elements using c(). Let's use single brackets to extract the first and third objects in the rugby_club list:
```{r}
rugby_club[c(1,3)]
# The output consists of a list of the first and third vectors that we stored in rugby_club:
# output:
# $club_title
# [1] "Rugby Club"

# $club_dues
# [1] 100  50
```

What happens if we use double brackets to index rugby_club?
```{r}
rugby_club[[c(3,2)]]
# Now, the output consists of the second element in the third object of the list:
# [1] 50
```

When objects in a list have names associated with them, we can use them for indexing.

The following three lines of code extract the elements contained in the third object in the rugby_club list:

Using the dollar sign ($) symbol to extract elements of a named object of a list:
```{r}
rugby_club$club_dues
# the output is: [1] 100  50
```

Using the name of the object to extract in brackets:
```{r}
rugby_club[["club_dues"]]
# the output is: [1] 100  50
```

Using the position of the object to extract in brackets:
```{r}
rugby_club[[3]]
# the output is: [1] 100  50
```

PRACTICE
Let's practice indexing the chess_club list.
Here is the chess_club list:
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20 15

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

Index the chess_club list to return the fourth object, a matrix.
Store the result in the variable meeting_matrix.

Index the third object of the chess_club list, club_dues, to return the second element of that object.
Store the result in the variable club_second_due.
```{r}
meeting_matrix <- chess_club[[4]]
club_second_due <- chess_club[[c(3,2)]]
```



6 of 10 · Modifying List Elements
Learn
In addition to extracting elements, we can also change specific list components.

For example, let's say you have been informed that the club dues paid by members at the start of the fall and spring semesters have increased by 10 USD each.

As a result, we'd like to change the values of club_dues we have stored in our rugby_club list:
```{r}
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 100  50
```

To replace the club_dues values in the rugby_club list with the new costs we've learned about, here are three ways to do it:
```{r}
rugby_club[[3]] <- c(110, 60) # c(..., ...) assigning a new value
#index the third object by position (using double brackets)

rugby_club[["club_dues"]] <- c(110, 60) 
#index the third object by name (using double brackets)

rugby_club$club_dues <- c(110, 60)
#index the third object by name using '$'
```

We can replace only one of the dues values. Let's say the club captains are considering discounting the fall semester dues by 50 USD to encourage more freshmen to join this year. To replace 110 with 60, we would write:
```{r}
rugby_club[[c(3, 1)]] <- 60 
# note that here we are indexing the first element of the third object.
```

Remember that use of the double brackets here specifies the first value of the third object in the list.

Let's modify the chess_club list to reflect new information our research has turned up. Currently, chess club members pay dues during the fall semester (50 USD), spring semester (20 USD), and during summer (15 USD) if they are staying on campus. Since few students stay on campus and snack costs are low, the club captain is reducing summer club dues to 5 USD.

Here is the chess_club list:
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20 15

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

Write code to replace the third element of club_dues to 5.

Display the third element of club_dues in the chess_club list to check that the third element of club_dues has changed.
practice:
```{r}
chess_club[[c(3, 3)]] <- 5
chess_club[[c(3, 3)]]
```



7 of 10 · Appending Elements to Lists
Learn
As we continue to research clubs, we might acquire more information that we want to incorporate into our existing lists.

Since one of the reasons we're looking to join clubs is to meet new friends, we'd like to join clubs that have lots of members who are also in their first year of university.

As we researched the clubs we're interested in, we found some information on the number of first-, second-, third-, and fourth-year university students who participated in the club during fall and spring semesters last year.

For the rugby club, we organized the information in the form of numeric data in a matrix named member_years_rugby:
```{r}
fall <- c(8, 12, 13, 2)
spring <- c(6, 11, 14, 3)

member_years_rugby <- rbind(fall, spring)
colnames(member_years_rugby) <- c("first_yr", "second_yr", "third_yr", "fourth_yr")

print(member_years_rugby)

# output:
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3
```

We'd like to add this matrix as an object to the rugby_club list, which currently contains three objects:
```{r}
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 80 60
```

Let's add member_years_rugby as a fourth object of the list. To add an element to a list, we can specify the position we want the new element to occupy using double brackets:
```{r}
rugby_club[[4]] <- member_years_rugby

# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 80 60

# [[4]]
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3
```

Let's make three important points here:

The new object we added is placed at the end of the rugby_club list.
The object is numbered in the list and not named since we used position indexing.
The object would overwrite an existing object if instead of specifying a new position, we specified an existing one (remember the previous screen where we modified an existing object in a list).
As we've seen above, objects added to a list do not have names associated with them unless we specify them.

We could assign a name to the object as we learned earlier in this lesson. If we want to append member_years_rugby to rugby_club and give it a name, we would write:
```{r}
rugby_club[["members_years_rugby"]]
member_years_rugby
```

Let's clarify the process here:

The new object is added at the end of the list without requiring us to indicate the current end of the list (contrary to when we use positions indexing like above).
A name is assigned to this object in the list.
We've researched chess club membership and found the following numbers of first-year members that joined during the fall and spring semesters last year:

Fall Semester: 12
Spring Semester: 15
Let's add this information to our chess_club list.


Practice
Instruction:
We have created a vector, first_years, that contains the number of first-year chess club members for last year's fall and spring semesters.

Add the first_years vector as an object, of the same name, to the end of the chess_club list.

Index chess_club to display the number of first-year students that participated in chess club during last year's spring semester.
```{r}
first_years <- c(12, 15)
names(first_years) <- c("fall", "spring")
# add code
chess_club[["first_years"]] <- first_years
chess_club$first_years[[2]]
```


8 of 10 · Removing Elements from a List
Learn
On this screen, we'll investigate how to remove elements from a list. Similar to removing elements from a vector by indexing them negatively, we can apply the same technique to remove elements from a list.

Let's demonstrate this using the chess_club list.
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20  5

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

We can remove values from a list by specifying their position preceded by a minus symbol (-) in square brackets ([]); not double square brackets. To remove the object in the second position of chess_club, we can write:
```{r}
chess_club[-2]
# output:
# $club_title
# [1] "Chess Club"

# $club_dues
# [1] 50 20  5

# $club_meetings
# _             [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

We can also remove multiple objects from a list by specifying more than one position preceded by a minus symbol (-) in square brackets ([]). To remove elements in the first and third position from the chess_club list, we would write:
```{r}
chess_club[c(-1, -3)]
# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_meetings
# _             [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

PRACTICE
The chess_club list is available from previous screens. Here is its content:
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20  5

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"  

# $first_years
#  fall spring 
#    12     15
```

Write code to remove the first object of the list, chess_club.

Store the result in the variable chess_club_without_1.
Write code to remove the object at the third and fourth positions of the chess_club list.

Store the result in the variable chess_club_without_34.
```{r}
chess_club <- list("club_title" = c("Chess Club"), 
                   "club_description" = c("Meets two nights a week for members to play chess. Snacks are provided."), 
                   "club_dues" = c(50, 20, 15), 
                   "club_meetings" = rbind(c("Monday", "Wednesday"),  c("6:00 pm", "8:00 pm")),
                   "first_years" = c("fall" = 12, "spring" = 15))

# add code

chess_club_without_1 <- chess_club[-1]
chess_club_without_34 <- chess_club[c(-3, -4)]
```


9 of 10 · Combining Lists
Learn
In this lesson, we've been creating lists of data for several clubs:

rugby_club
ballroom_dancing
chess_club
Perhaps we'd like to combine them into a single list.

The syntax for combining multiple lists is similar to that of combining vectors. To combine the rugby_club and ballroom_dancing lists into a new list called university_club_data, we can use the c() function:
```{r}
university_club_data <- c(rugby_club, ballroom_dancing)
# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 80 60

# $member_years_rugby
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3

# $club_title
# [1] "Ballroom Dancing Club"

# $club_description
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# $club_dues
# [1] 150
```

Combining lists using c() appends lists to one another, end-to-end, to create a single list. We can use it to combine as many lists as necessary.

The university_club_data list is confusing because some of the elements, like club_description, have the same name. We need a way to combine lists that preserve the organization of each list.

Recall that lists can contain any type of data object, including other lists. Instead of combining elements of the three lists into a single list as we did using c(), we can use the list() function to create a new list of lists. Let's create a list of lists, university_club_list, to illustrate how this works.

Recall the syntax for creating a list of named objects from earlier in this lesson:
```{r}
universty_club_list <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing)
# output:
# $rugby_club
# $rugby_club$club_title
# [1] "Rugby Club"

# $rugby_club$club_description
# [1] "Plays matches against clubs from local universities"

# $rugby_club$club_dues
# [1] 80 60

# $rugby_club[[4]]
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3

# $rugby_club$member_years_rugby
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3


# $ballroom_dancing
# $ballroom_dancing$club_title
# [1] "Ballroom Dancing Club"

# $ballroom_dancing$club_description
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# $ballroom_dancing$club_dues
# [1] 150
```

Notice that the name of each object in university_club_list follows the name of the list it belongs to (either rugby_club or ballroom_dancing), making it much clearer and organized.

Creating a list of lists will be a technique we use when we want to perform the same operation on multiple lists at the same time in future courses.

For now, let's practice by creating a list of the three lists of club data we've worked with in this lesson.
```{r}
university_clubs <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing, chess_club = chess_club)
```

10 of 10 · Next Steps
```{r}
