---
title: "R Data Analytics"
output: html_document
date: "2024-10-24"
---

Putri's learning on DATAQUEST


Materials and Practice
Project: Install RStudio
6 of 11 · Installing Tidyverse Packages Collection

Tidyverse is a collection of packages needed for data analysis.
These are the most common packages:
```{r}
readr #for data import.
ggplot2 #for data visualization.
dplyr #for data manipulation.
tidyr #for data cleaning.
purrr #for functional programming.
tibble #for tibbles, a modern re-imagining of dataframes.
stringr #for strings.

# install tidyverse
install.packages("tidyverse")

library(readr)
library(ggplot2)

# it's also possible to load them all using:
library(tidyverse)

```

7 of 11 · Importing Data
Learn
When we write code to import a dataset into RStudio, we must make sure that we have the working directory set to the location where our data files are stored. Otherwise, we'll have to specify the file location.

There are a few ways to set the working directory in RStudio.

Use the setwd() function. We can use this function to set our working directory to the Desktop folder by typing: setwd("~/Desktop") in the Console.

Navigate to and choose the working directory from the Session menu.

To print our working directory in the Console, type getwd().

In other lessons, we learned we'll often want to import data into R. We learned to use the read_csv() function in the readr package to import data and assign the dataframe to a variable. Datasets we import into R as dataframes display in the Environment tab as well. To demonstrate this, you can download a dataset. We will use it in the following screens.

Make sure to download this dataset and store it in your working directory.

As an alternative to typing code in the Console, we can import datasets into RStudio using the Import Dataset feature in the Environment tab.

We recommend using the readr option, which uses functions, like read_csv(), that we learned about earlier in this course.

If we import data into R using the Import Dataset feature, the data automatically displays in a tab located on the top-left of the interface.

If we import our data into R by typing functions like read_csv() in the Console, R does not automatically open the data file. To display our data, we use the function View(). For example, to look at the dataframe we created in a previous lesson when we imported data on Monster Jobs into R, we would type the following code into the Console:
```{r}
View(monster_jobs)
```

8 of 11 · Writing Scripts
In RStudio, we can write scripts in the text editor window at the top left of the interface. To create a new script, use the create new script drop down menu at the top right of the interface or commands in the file menu. You can also use the keyboard shortcut Ctrl + Shift + N for windows and Command + Shift + N for macOS.
```{r}
# loading packages
library(readr)
library(ggplot2)

# loading the monster_jobs dataset
monster_jobs_clean <- read_csv("monster_jobs_clean.csv")
view(monster_jobs_clean)

# plotting job_id vs salary_min
ggplot(data = monster_jobs_clean, aes(x = job_id, y = salary_min, color = job_type)) + geom_point() + labs(tittle = "Job ID vs Minimum Salary", x = "Job ID", y = "Minimum Salary", color = "Job Type")
```
To run a line of code we typed into our console's script, we place the cursor on the line and then, we can either click run at the top right of the script or use the following keyboard commands:

OS X: Cmd + Enter
Windows and Linux: Ctrl + Enter

We can also highlight multi-line chunks of our code that we want to run.

Sometimes, we'll write a script we want to run all at once. To highlight all the code in our script, we can use the command:

OS X: Cmd + a
Windows and Linux: Ctrl + a

When writing a script, it's good practice to begin at the top by writing code to load the packages we'll need to run the script:

```{r}
library(readr)
library(ggplot2)
```


Vectors in R
1 of 11 · Introduction to Data Structures: Generating Vectors

Learn
Understanding data structures is fundamental in R programming. They are the tools that help us store and work with data efficiently.

In this course we will learn the following data structures:

Vector: A one-dimensional container for storing values of SAME TYPE.
Matrix: A two-dimensional structure for storing values of SAME TYPE.
Lists: A versatile multi-dimensional stucture for storing values of ANY DATA TYPE/OBJECT.
Dataframe: Another two-dimensional structure for storing values of ANY DATA TYPE/OBJECT.
Here's a visual representation to help you picture these structures:


Learning about data structures involves:
- Creating them.
- Accessing their elements (indexing).
- Adding or removing elements.
- Using them in various operations and tasks.
In this lesson, we will focus on vectors. We'll build on the skills we learned in the previous course as we dive deeper into creating, manipulating, and performing calculations with vectors.

So, what is a vector? It is a data structure that holds a collection of values of the same type, allowing us to perform operations on them collectively. Think of it like an array in other languages like Python.

In the previous course, we encountered basic data types like logical, numeric (integer and double), and character. In this lesson, we will create vectors for each of these types:
- Logical vector.
- Integer vector.
- Double vector.
- Character vector.

Creating vectors is straightforward. We can generate a sequence of values in different ways:

A range of values like 1, 2, 3, and 4, can be generated as a vector using a colon (:) in R.

```{r}
a_range_vector <- 1:4
```
A sequence of values based on specific rules, such as 2, 5, and 8, can be generated using the seq() function:

```{r}
seq_2_10 <- seq(from = 2, to = 10, by = 3)
print(seq_2_10)
```
We can also repeat a value a specified number of times (times) with the rep() function:

```{r}
rep_4 <- rep(5, times = 4)
print(rep_4)
```

Plus, the rep() function can even repeat an entire vector:
```{r}
rep_6 <- rep(1:3, times = 2)
print(rep_6)
```


```{r}
vector_1 <- rep(4, times = 10)
vector_2 <- 1:12
vector_3 <- seq(from = 2.0, to = 5.50, by = 0.25)
```
2 of 11 · Creating a Vector Using Known Values
Learn
On this screen, we learn how to create a vector using known values.

A vector is created using the function c()(which stands for concatenate). This function receives a sequence of values of the SAME TYPE separated by commas (,) and it will transform them into a vector. Here are some practical examples:

A logical vector for making validation decisions in classes:
```{r}
c(TRUE, FALSE, FALSE)
c(TRUE, FALSE, TRUE, FALSE)
```

An integer vector that contains the scores of a game:
```{r}
c(12L, 3L, 24L, 8L)
c(21L, 13L)
```

A double vector that contains the selling prices of products:
```{r}
c(12.10, 24.90, 4.99)
c(21.10, 25.50, 35.50)
```

A character vector that contains names of the days of the week:
```{r}
c("Monday", "Tuesday", "Wednesday","Thursday", "Friday", "Saturday","Sunday")
c("Haruto", "Junkyu", "Asahi", "Doyoung", "Yoshi", "Jihoon")
```

Remember that R follows specific syntax rules in order for the computer to perform our instructions. If we try to store a sequence of values without the c() function:
```{r}
# selling_prices <- 12.10, 24.90, 4.99
```
We will recieve the following error message

Practice:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```


3 of 11 · Indexing Vectors by Position
Learn
On this screen, we'll investigate how a vector is structured and how we can index (i.e. access) an element in a vector.

Recall the vectors we created on the previous exercise:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

When you store these vectors in R, each value within them is assigned a position number (called an index) in memory. These positions allow us to access individual values within the vector. R follows a 1-indexed system, meaning the first element in a vector has a position of one.

To extract values from the vector, we specify their position within square brackets ([]). For example, to retrieve the value in the third position of math_grades, we can write:
```{r}
math_grades[3]
```
which returns:
```{r}
# output: [1] 85
```
We can also extract multiple values of a vector by specifying a range of positions using a colon (:). To select the first through fourth elements of the exam_grades vector, we would write:
```{r}
exam_grades[1:4]
# output: [1] 92 90 84 95
```
What if we want to select vector elements that are not next to each other? To do so, we can create a new vector of the desired indices and use this new vector of indices to extract the desired values from the original vector. To select elements in the first, third, and seventh positions of the exam_grades vector, we would write:
```{r}
exam_grades[c(1, 3, 7)]
# output: [1] 92 84 85
```

Practice:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
# Add your code below
math_exam_grade <- math_grades[1]
desired_exam_grades <- exam_grades[c(2, 3, 6)]
non_stem_exam_grades <- exam_grades[3:7]
```

4 of 11 · Indexing Vectors using Logicals
Learn
On the previous screen, we learned how to index element in a vector based on the vector structure.

Here are the vectors we created in the previous exercise.
```{r}
math_exam_grade <- math_grades[1] # extracting a single element
non_stem_exam_grades <- exam_grades[c(3:7)] # extracting a range of elements
desired_exam_grades <- exam_grades[c(2, 3, 6)]  # extracting a list of desired elements
```

Let's extract the grades of STEM classes from the exam_grades vector. To guide us, the is_stem_classes vector contains the following values:
```{r}
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

Based on what we have learned so far, we can create a vector of indices where is_stem_classes is TRUE and use it to extract the desired values.
```{r}
exam_grades[c(1, 2)]
# output: [1] 92 90
```

However, this approach is not scalable, especially with larger vectors where identifying every TRUE value would be cumbersome. Luckily, R offers a more elegant solution: logical indexing. Thus, to extract the grades of STEM classes using the is_stem_classes vector, we can do:
```{r}
exam_grades[is_stem_classes]
# output: [1] 92 90
```

Practice:
```{r}
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
# Add your code below
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
preferred_homework_grades <- homework_grades[is_stem_classes]
```

Vectors in R
5 of 11 · Modifying Elements in a Vector
Learn
On the two previous screens, we learned how to extract elements from a vector using various methods.

- To extract a single element: math_grades[1].
- For a range of elements: exam_grades[c(3:7)].
- To select specific elements using an integer vector of indices: exam_grades[c(2, 3, 6)].
- For filtering elements based on a logical vector: exam_grades[is_stem_classes].

On this screen, we'll learn how to modify the elements of a vector. Luckily, we can achieve this by using two notions that we have already learned: assignment with <- and indexing.
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
```

To replace the third grade in math_grades by 90L, we can write:
```{r}
math_grades[3] <- 90L #modify the third element of the vector
print(math_grades) 
# output: [1] 92 87 90
```

We can see that the third value has changed. Here's how R handles it:

First, it identifies the element we would like to modify using its index.
Then, it updates that specific element with the new value.
We can therefore make similar modifications using the other indexing methods.

Using a vector of indices:
```{r}
exam_grades[c(3:7)] <- 85
print(exam_grades)
# output: [1] 92 90 85 85 85 85 85
```

Using logicals
```{r}
exam_grades[is_stem_class] <- 95 
print(exam_grades) 
# output: [1] 95 95 84 95 77 92 85
```

Practice:
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)

math_grades[2] <- 80L
exam_grades[is_stem_classes] <- 92
```

6 of 11 · Appending Elements to a Vector
Learn
It turns out that there are three additional class grades that we didn't initially consider in our dataset.

The exam_grades vector contains the following values.
```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
```

The three additional exams' grades are stored in the vector extra_exam_grades.
```{r}
extra_exam_grades <- c(75, 85, 95)
```

To add these three values to the existing vector we can manually add these three elements.
```{r}
new_exam_grades <- c(92, 90, 84, 95, 77, 92, 85, 75, 85, 95)
```

However, this approach can become quite cumbersome, especially with larger vectors. Fortunately, R provides an efficient solution using the c() function:
```{r}
new_exam_grades <- c(exam_grades, extra_exam_grades)
print(new_exam_grades)
# output: [1] 92 90 84 95 77 92 85 75 85 95
```

This code creates a new vector, new_exam_grades, by appending the elements in extra_exam_grades to the vector exam_grades.

We can also reverse this process by appending the elements in exam_grades to the vector extra_exam_grades by swapping their positions like this:
```{r}
new_exam_grades <- c(extra_exam_grades,exam_grades)
print(new_exam_grades) 
# output: [1] 75 85 95 92 90 84 95 77 92 85
```

practice:
```{r}
extra_is_stem_classes <- c(TRUE, FALSE, FALSE)
new_is_stem_classes_end <- c(is_stem_classes, extra_is_stem_classes)
new_is_stem_classes_start <- c(extra_is_stem_classes, is_stem_classes)
```


7 of 11 · Removing Elements from a Vector
Learn
On this screen, we'll investigate how to remove elements from a vector by applying negative indexing. First, let's recall the content of the math_grades and exam_grades vectors.
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
```

To remove a value from the vector, we specify their positions preceded by a minus symbol (-) within square brackets ([]). To remove the value in the third position of math_grades, we can write:
```{r}
math_grades[-3]
#output: [1] 92 87
```

With negative indexing, we've removed the element in the third position. We can also remove multiple values from a vector by creating a vector of indices to exclude preceded by a minus symbol (-). To remove elements in the first, third, and seventh positions from the exam_grades vector, we would write:
```{r}
exam_grades[-c(1, 3, 7)]
#output: [1] 90 95 77 92
```

practice
```{r}
math_without_exam_grades <- math_grades[-1]
above_90_exam_grades <- exam_grades[-c(3, 5, 7)]
```



8 of 11 · Performing Operations with Vectors
Learn
We learned to perform operations on single values/variables in the previous course. It is also possible to perform the same operations with vectors. In the later case, element-wise operations are performed. Element-wise operation means to perform operations on every element of multiple vectors at once. This is a very powerful feature of R.
We can start by creating three vectors, one for each assignment category, to work with:
```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)
```

If we are interested in calculating the final scores for each class, we could calculate each class grade individually:
```{r}
math <- (92 + 87 + 85) /3
chemistry <- (90 + 81 + 92)/3 # and so on.
```

However, as we work with larger datasets in R, this manual appraoch becomes impractical. Instead of calculating each final grade individually, we can use vector arithmetic to perform these calculations.

In vector arithmetic, operations are performed between values in the same position of two vectors. For example, let's add Johnny's exam_grades and homework_grades vectors and save the output as a new vector called sum_grades:
```{r}
sum_grades <- exam_grades + homework_grades
```

practice: 
```{r}
class_scores_sum <- exam_grades + homework_grades + project_grades
class_scores_avg <- class_scores_sum / 3
```


9 of 11 · Vector Recycling
Learn
In the previous example, we calculated class scores by performing vector arithmetic. In that scenario, the three vectors we're working with were of the same length. Each had seven values for the seven classes. This isn't always the case, though. For example, what if a grade is missing, like the last homework grade?

When the length of two vectors don't match, R employs a feature called recyclying (or repetition), in order to make them compatible. Here, the shorter vector is recycled until it matches the length of the longer one.

To show how R's recycling behavior works when we perform operations on vectors of different lengths, let's shorten our homework vector to only six values:

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90)
```

Let's now add the vectors exam_grades and homework_grades.
The R interpreter determines that the homework_grades vector is shorter than the exam_grades vector and automatically recycles the values in the homework_grades vector until the two vectors are the same length. 

Once the vector lengths match, the R interpreter performs the specified arithmetic operation.

When we perform operations on vectors of unequal lengths in R, we receive the following warning message:
```{r}
# Warning message in exam_grades + homework_grades:
# “longer object length is not a multiple of shorter object length”
```

R still performs the calculation. The warning message alerts us to the possibility that the different vector lengths were not intended.

Typically, vector recycling is an interesting feature in R, but should always be used wisely.
- It can be very useful in operations where repetition is natural. For example, with timed data. If we have a vector with 30 days of data (vector_30_days) that we want to sum with a vector of 7 days of data, i.e, data for a week (vector_week), recycling can work well and yield the right result: vector_30_days + vector_week.

- It can also be misleading if the repetition is not desirable. On this screen's example, it may be inappropriate to consider the grade of the first two classes as grades of missing classes.

Scenario of writing programs to calculate the average scores for each class when some grades are missing.

practice:
```{r}
exam_grades <- c(92, 90, 84)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)
# Add your code below
class_scores_sum_recycled <- exam_grades + homework_grades + project_grades
class_scores_avg_recycled <- class_scores_sum_recycled / 3
```


10 of 11 · Vectors Using Names
Learn
Previously, we had learned that in the structure of a vector, each element in a vector is indexed by a number that represents the position of that element. We can also manipulate and access elements of a vector using names, instead of positions.

As we illustrate how it works, let's consider our running dataset again.
```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

Is there a way to manipulate the names of these values instead of their positions? For example, in the vector math_grades, we would like to identify the first element as the Exams grade, the second as Homework grade and the last as the Projects grade.

We can achieve this by specifying the name of each value using the equal (=) when creating the vector.
```{r}
math_grades <- c("Exams"=92L, "Homework"=87L, "Projects"=85L)
# output:
# Exams Homework Projects 
#  92       87       85
```

When the set of names already exists as a vector we can also achieve this by using the names() function.
```{r}
grade_names <- c("Exams", "Homework", "Projects")
math_grades <- c(92L, 87L, 85L)
names(math_grades) <- grade_names
# output: 
# Exams Homework Projects 
#   92       87       85
```

Fortunately, all indexing methods we learned can be applied using names also. For example, to get the first element ("Exams") and the last element ("Projects") of the math_grades vector, we write:
```{r}
math_grades[c("Exams", "Projects")]
# output: 
# Exams Projects 
#   92       85
```

We can replace these values with another one.
```{r}
math_grades[c("Exams", "Projects")] <- 80L
# output: Exams Homework Projects 
#          80       87       80
```

If we call the names() function in a vector without assigned names, the function returns the names' vector or NULL if there is no name.

practice:
```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)

class_names <- c("math", "chemistry", "writing", "art", "history", "music", "physical_education")
# Add code
names(exam_grades) <- class_names
names(homework_grades) <- class_names
names(project_grades) <- class_names
```

11 of 11 · Next Steps
In this lesson, we've learned fundamental skills on how to create, manipulate, add attributes to, index, and perform calculations using vectors. Vectors are a key data structure in R, and the knowledge gained in this lesson forms the basis for more complex data analysis.

In the next lesson, we'll dig deeper into analysis as we work with real-world data on university rankings. Now that we've learned the basics of working with vectors, we'll expand our R capabilities as we work with two-dimensional data structure: matrices.



Matrices in R
1 of 11 · Creating Matrices by Restructuring Vectors
Learn
In this lesson, we'll learn how to create matrices by restructuring vectors using the matrix() function. Understanding matrices is a very crucial skill for effective data manipulation and analysis in R. The good news is that we'll be reusing the skills from the vector lesson as we dive deeper into creating, manipulating, and performing calculations with matrices.

A matrix is a two-dimensional data structure used to store values of the same data type. Similar to vectors, matrices can be of type logical, numeric (integer and double), and character. Unlike vectors (one-dimension) that can be indifferently considered as a column or a row, matrices are two-dimensional, which introduces the concepts of rows and columns.

As we learned in the vectors' lesson, learning to work with data structures is critical for programming in R, because efficient data storage and operations rely on them. Remember that there are four data structures that will be covered in this course.

One way to create a matrix is by restructuring a vector into a matrix using the matrix() function. This restructuring can be done in two ways: by column (the default) or by row. The function receives the vector to restructure into a matrix, and the number of rows (nrow) and columns (ncol).

To demonstrate this default column way, let's restructure a vector without specifying ncol parameter:
```{r}
mat_3x2_bycol <- matrix(1:6, nrow = 3)
print(mat_3x2_bycol)
# output:
# _    [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6
```

Now, let's specify the ncol parameter:
```{r}
mat_3x2_bycol <- matrix(1:6, nrow = 3, ncol = 2)
print(mat_3x2_bycol)
# output:
# _    [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6

# We get the same result
```

If we want to restructure the vector by row, we have to set the byrow parameter to TRUE in the matrix() function.
```{r}
mat_3x2_byrow <- matrix(1:6, nrow = 3, ncol = 2, byrow = TRUE)
print(mat_3x2_byrow)
# output:
# _    [,1] [,2]
# [1,]    1    2
# [2,]    3    4
# [3,]    5    6

# byrow = TRUE indicates that the vector should be filled in by row
# If byrow = FALSE (which is the default), the vector would be filled in by column.
```

We can also provide either nrow or ncol in the matrix() function and R will automatically deduce the missing parameter by dividing the length of the vector by the provided parameter.
```{r}
# automatic determination of columns
matrix(1:6, nrow = 3) # equivalent to ncol: 6 / nrow = 2
# automatic determination of rows
matrix(1:6, ncol = 2) # equivalent to nrow: 6 / ncol = 3
```

Of course, we can use the matrix() function to restructure any kind of vector into a matrix. Here are other examples.

A logical matrix that decides which classes are validated or not for two students (each row represents a student):
```{r}
is_validated <- c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)
mat_is_validated <- matrix(is_validated, nrow = 2)
print(mat_is_validated)
# output: 
# _     [,1]  [,2] [,3]
# [1,]  TRUE FALSE TRUE
# [2,] FALSE  TRUE TRUE
```

An integer matrix that contains a sequence of values from 2 to 11 by 3 restructured into a matrix of two columns and rows.
```{r}
matrix(seq(from = 2, to = 11, by = 3), nrow = 2, ncol = 2)
# we use the seq() function to create our sequence of values and we don't store the result in a variable

# output:
# _    [,1] [,2]
# [1,]    2    8
# [2,]    5   11
```

A character matrix that contains names of the days of a week:
```{r}
days_names <- c("Wed", "Thu", "Fri", "Sat", "Sun", "Mon", "Tue")
vector_month_days <- rep(day_names, 4)
matrix_month_days <- matrix(vector_month_days, nrow = 4, ncol = 7, byrow = TRUE)
print(matrix_month_days)
# output:
# _    [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7] 
# [1,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
# [2,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
# [3,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
# [4,] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Tue"
```

practice:
```{r}
vector_1 <- c(1, 4, 5, 9) # [1] 1 4 5 9
vector_2 <- 1:12 # [1] 1  2  .. 11 12
vector_3 <- seq(from = 2.0, to = 5.50, by = 0.25) # [1] 2.00 2.25 .. 5.25 5.50
# Add code
matrix_1 <- matrix(vector_1, nrow = 2, ncol = 2)
matrix_2 <- matrix(vector_2, nrow = 4, ncol = 3)
matrix_3 <- matrix(vector_3, nrow = 3, ncol = 5, byrow = TRUE)
```


2 of 11 · Creating a Matrix by Combining Vectors
Learn
On the previous screen, we learned how to create a matrix by restructuring a vector using the matrix() function. On this screen, we will learn how to create a matrix by combining vectors.


Combining vectors into matrices is straightforward because of similarities in the two data structures. Both consist of a single data type (here, numeric). 

To combine the vectors into a matrix, we can use the rbind() function. The "r" in rbind() stands for rows — this function allows us to combine multiple vectors by row. 

To demonstrate this, let's combine the universities vectors using rbind():
```{r}
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)

university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)
print(university_matrix)
# output:
# _         [,1] [,2] [,3] [,4] [,5]
# harvard      1    1    1    1    3
# stanford     2    9    3    4   10
# MIT          3    3    2    2    1
# cambridge    4    2    6   13   48
# oxford       5    7   12    9   15
# columbia     6   13   13   12    4
```

To combine vectors into a matrix, remember we can also use the function cbind(). The "c" in cbind() stands for columns — this function also allows us to combine multiple vectors, but, by column.

practice:
```{r}
world_rank <- c(1, 2, 3, 4, 5, 6)
quality_of_education <- c(1, 9, 3, 2, 7, 13)
influence <- c(1, 3, 2, 6, 12, 13)
broad_impact <- c(1, 4, 2, 13, 9, 12)
patents <- c(3, 10, 1, 48, 15, 4)
# add code
university_matrix <- cbind(world_rank, quality_of_education, influence, broad_impact, patents)
```



3 of 11 · Naming Matrix Rows and Columns

When we use the rbind() function to create a matrix from vectors with name attributes, the vector names are retained as row name attributes. However, our columns don't have any name attributes associated with them. Adding names to rows or columns of a matrix is similar to naming elements of a vector.

Keep in mind that attributes are different from elements of vectors or matrices — they are not stored in these data structures, and you cannot perform operations on them. Attributes make interpreting the contents of vectors and matrices easier.

In the previous lesson, we learned to add name attributes to vectors using the attribute accessor function names(). Since matrices have both rows and columns, there are separate functions for adding name attributes to each:

Rows: rownames()

Columns: colnames()

We already have university names for rows of university_matrix, but we need to add column names so that we can see the categories for each university's ranking.

Let's name the columns in the university_matrix we created in an earlier example:
```{r}
university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)
colnames(university_matrix) <- c("world_rank", "quality_of_education", "influence", "broad_impact", "patents")
```

If we inspect university_matrix by printing it, we can see the columns are named:
```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```

Naming rows using rownames() uses the same syntax.

As with vectors, if we call the rownames() or colnames() functions in a matrix without assigned names, the function will return the names of rows or columns, or NULL if there is no name.

practice:
```{r}
rownames(university_matrix) <- c("harvard", "stanford", "MIT", "cambridge", "oxford", "columbia")
# output:
# _         world_rank quality_of_education influence broad_impact patents 
# harvard     1           1                   1         1           3 
# stanford    2           9                   3         4           10 
# MIT         3           3                   2         2           1 
# cambridge   4           2                   6         13          48 
# oxford      5           7                   12        9           15 
# columbia    6           13                  13        12          4
```


4 of 11 · Indexing Matrices by Columns and Rows
Learn
Earlier in this course, we learned how to index (i.e., access) vectors, in order to extract specific elements. We can also index matrices. Since matrices are two-dimensional objects, we can index to select:
a specific value
matrix[row, column]

a specific row
matrix[row_index,]

a specific column
matrix[, column_index]


The syntax for indexing matrices is similar to that for indexing vectors. We can extract values from the matrix by specifying the row and/or column positions in square brackets ([]) separated by comma(,).

Let's use the university_matrix to illustrate how to index a matrix.
```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```


To return the value in the third row (representing MIT) and second column (corresponding to quality_of_education) of university_matrix, we can write:
```{r}
university_matrix[3, 2] # number indexing
# output: 
# [1] 3
```

We can also use the row name ("MIT") and the column name ("quality_of_education""):
```{r}
university_matrix["MIT", "quality_of_education"] # name indexing
# output:
# [1] 3
```

To return all the values in the third row (MIT) of university_matrix only, we can write:
```{r}
university_matrix[3, ] # we left the column's place empty after comma

# which returns a named vector:
# output:
# world_rank quality_of_education   influence   broad_impact   patents 
#         3                    3           2              2         1
```

We can also use the row name ("MIT"):
```{r}
university_matrix["MIT", ] #we left the column's place empty after the comma
# which returns a named vector:
# output:
# world_rank quality_of_education   influence   broad_impact   patents 
#         3                    3           2              2         1
```

To return all the values in the second column (quality_of_education) of university_matrix only, we can write:
```{r}
university_matrix[ , 2] # we left the column's place empty before the comma
# output:
# harvard  stanford    MIT cambridge    oxford  columbia 
#     1         9      3         2         7        13
```

We can also use the column name ("quality_of_education"):
```{r}
university_matrix[ , "quality_of_education"] #we left the row's place empty before the comma
# output:
# harvard  stanford   MIT cambridge    oxford  columbia 
#      1         9     3         2         7        13
```

practice:
```{r}
cell_columbia_influence <- university_matrix["columbia", "influence"]
vector_cambridge <- university_matrix["cambridge", ]
vector_world_rank <- university_matrix[ ,"world_rank"]
```



5 of 11 · Indexing Matrices using Vectors
Learn
recap

The syntax for indexing a matrix is matrix[row, column]. In the square brackets ([]), we indicate the row index first, then the column index and both are separated by a comma (,).
We can index (i.e., access) a specific value by indicating its row and its column: matrix[row, column].
We can index (i.e., access) a specific row by indicating the row index/name, leaving the column's place empty in the square bracket: matrix[row, ].
We can index (i.e., access) a specific column by indicating the column index/name, leaving the row's place empty in the square bracket: matrix[ , column].
Meanwhile, in the previous lesson, we learned that a vector can also be indexed by another vector. The indexing vector can be:
- a range of integer values,
- an integer vector of indices,
- a logical vector, or
- a character vector of names.
We can also index matrices the same way.

```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```

To return the values in the first three rows (harvard, stanford, and MIT) and the second column (quality_of_education) of university_matrix, we can write:
```{r}
university_matrix_[1:3, 2]
# output:
# harvard stanford  MIT 
#      1        9    3
```

We can also use the rows and columns names:
```{r}
university_matrix[c("harvard", "stanford", "MIT"), "quality_of_education"]
# output: 
# harvard stanford  MIT 
#      1        9    3
```

To return the rankings for the USA's universities (i.e., Harvard, Stanford, MIT, and Columbia):
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE) # e.g. the first TRUE means Harvard is an American university.
university_matrix[usa_universities, ] # notice the absence of the column index
# output:
# _        world_rank quality_of_education influence broad_impact patents
# harvard           1                    1         1            1       3
# stanford          2                    9         3            4      10
# MIT               3                    3         2            2       1
# columbia          6                   13        13           12       4
```

To return the rankings for the USA's universities (i.e., Harvard, Stanford, MIT, and Columbia) in the influence, broad impact, and patents categories:
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
university_matrix[usa_universities, c(3, 4, 5)] #instead of c(3, 4, 5) we can use 3:5 or the names of the columns
# output:
# _        influence broad_impact patents
# harvard          1            1       3
# stanford         3            4      10
# MIT              2            2       1
# columbia        13           12       4
```

practice:
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
# add code
sub_matrix <- university_matrix[c("harvard", "MIT", "cambridge"), c("world_rank", "broad_impact")]
usa_universities_rankings <- university_matrix[usa_universities, c("world_rank", "patents")]
```


6 of 11 · Modifying Elements in a Matrix
Learn
In this screen, we learn how to modify the elements of a matrix. Luckily, we can achieve this by applying two concepts that we have already learned: assignment using <- and indexing.

matrix sample:
```{r}
# _         world_rank quality_of_education influence broad_impact patents
# harvard            1                    1         1            1       3
# stanford           2                    9         3            4      10
# MIT                3                    3         2            2       1
# cambridge          4                    2         6           13      48
# oxford             5                    7        12            9      15
# columbia           6                   13        13           12       4
```

To replace the value in the third row (MIT) and second column (quality_of_education) of university_matrix by 2, we can write:
```{r}
university_matrix[3, 2] <- 2 
# modify the element at the third row and second column
```

We can see that the element in the third row and the second column has changed. Actually, R first located the element that we would like to modify (by indexing) and then modified its content by assigning the new value to it.

We can, therefore, make similar modifications using the other indexing methods.
```{r}
university_matrix[usa_universities, 3:5] <- 1
```

practice:
```{r}
university_matrix <- cbind(world_rank, quality_of_education, influence, broad_impact, patents)
rownames(university_matrix) <- c("harvard", "stanford", "MIT", "cambridge", "oxford", "columbia")

usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)

# add code
university_matrix[4, 5] <- 3
university_matrix[c(1, 2, 3, 6), ] <- 2
```


7 of 11 · Appending Elements To a Matrix
Learn
Let's return to our initial goal: Deciding which university to attend. As we look at our data, we notice that while we have information to help us assess the quality of education and impact of the six universities, we also would like to have information on the cost of tuition for each university.

To address this, we've done some research and gathered data on annual tuition, in U.S. dollars, for each university:
Harvard $43,280
Stanford $45,000
MIT $45,016
Cambridge $49,350
Oxford $28,450
Columbia $55,161

Now, our plan is to add this tuition data to our matrix so that we can proceed with analyzing the data to enable us make an informed decision on our university choice.

First, let's create a vector containing the tuition data:
```{r}
tuition <- c(43280, 45000, 45016, 49350, 28450, 55161)
```

Next, we need to add the tuition vector to university_matrix as a column.

If we want to add the vector tuition as a new column to the university_matrix matrix, its length should be equal to the number of rows in university_matrix.

Earlier in this lesson, we used the rbind() function to combine the university rankings vectors into a single matrix. The rbind() function combines vectors or matrices by row. To add a vector to a matrix as a column or to join two matrices together by column, we used the cbind() function. This means that the cbind() function combines vectors or matrices by column.

To add the vector tuition as a new column to the university_matrix matrix, we can use the cbind() function.
```{r}
cbind(university_matrix, tuition)
# output:
# _         world_rank quality_of_education influence broad_impact patents tuition
# harvard            1                    1         1            1       3   43280
# stanford           2                    9         3            4      10   45000
# MIT                3                    3         2            2       1   45016
# cambridge          4                    2         6           13      48   49350
# oxford             5                    7        12            9      15   28450
# columbia           6                   13        13           12       4   55161

  
```

Note: If the matrix does not display correctly, adjust the vertical separator between the learning session and the editor.
The functions rbind() and cbind are similar in terms of syntax. To practice, let's add the rankings for the University of California, Berkeley, as a new row to the university_matrix using the rbind() function.

practice:
```{r}
california <- c(7, 5, 4, 7, 29, 43176)
# add code
complete_university_matrix <- rbind(university_matrix, california)
```


8 of 11 · Removing Elements from a Matrix
Learn
In this screen, we'll investigate how to remove elements from a matrix. To remove elements from a matrix, we use negative row/column index. Before explaining this, let's recall the content of the complete_university_matrix.
```{r}
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# stanford            2                    9         3            4      10   45000
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
# california          7                    5         4            7      29   43176
```

We can remove values from the matrix by specifying their row and column preceded by a minus symbol (-) in square brackets ([]). To remove the second row of complete_university_matrix, we can write:
```{r}
complete_university_matrix[-2, ]
# output:
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
# california          7                    5         4            7      29   43176
```

To remove the second and third columns from the USA universities, we can write:
```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)
complete_university_matrix[usa_universities, c(-2, -3)]
# output:
# _          world_rank broad_impact patents tuition
# harvard             1            1       3   43280
# stanford            2            4      10   45000
# MIT                 3            2       1   45016
# columbia            6           12       4   55161
# california          7            7      29   43176
```

To remove the second, third and fourth columns from complete_university_matrix where the tuition is greater than or equal to 45000, we can write:
```{r}
complete_university_matrix[tuition >= 45000, c(-2, -3, -4)]
# output:
# _         world_rank patents tuition
# stanford           2      10   45000
# MIT                3       1   45016
# cambridge          4      48   49350
# columbia           6       4   55161
```

practice:
```{r}
university_matrix_wtho_first <- complete_university_matrix[ , -1]
below_10_university_matrix <- complete_university_matrix[broad_impact <= 10, c(-2, -5)]
```


9 of 11 · Performing Operations with Matrices
Learn
We learned to perform operations on single values/variables in the previous course. The same operations can also be performed with matrices. In the latter case, element-wise operations are performed. Element-wise operation means to perform operations on every element of a matrice at once. This is a very powerful feature of R.

As we illustrate how this works, let's consider our running dataset, complete_university_matrix.
```{r}
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# stanford            2                    9         3            4      10   45000
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
# california          7                    5         4            7      29   43176
```

Let's say we want to calculate an aggregate ranking for each university. One way to do this is by calculating the sum of their rankings in every category and we can use the function sum() for this purpose. We use indexing to specify the university row we want to calculate a score for and then, also use negative indexing to remove the sixth column (tuition) which is not a ranking, like this:
```{r}
sum(complete_university_matrix["harvard", -6])
sum(complete_university_matrix["stanford", -6])
sum(complete_university_matrix["MIT", -6])
# output:
# [1] 7 
# [1] 28
# [1] 11
```

However, we're learning to use R with larger datasets. Instead of calculating each university score, we can use the function rowSums() to perform these calculations. Hence, it won't be necessary to specify the row name.
```{r}
row_Sums(complete_university_matrix[ , -6])
#output:
# harvard   stanford    MIT  cambridge   oxford   columbia california 
#      7         28     11         73       48         48         52
```

We can also use the function colSums() to compute an aggregate ranking for each category summing rankings for every university.
```{r}
colSums(complete_university_matrix[ , -6])
# output:
# world_rank quality_of_education  influence   broad_impact   patents         
#       28                   40         41             48       110
```

In addition to functions sum(), rowSums(), and colSums(), R provides the mean(), rowMeans(), and colMeans() functions for calculating average scores, which have a similar syntax as the functions we've just learned. These functions are available when you need to compute average values from your matrices.

practice:
```{r}
harvard_scores_avg <- mean(complete_university_matrix[ 1, -6])
university_scores_avg <- rowMeans(complete_university_matrix[ , -6])
category_scores_avg <- colMeans(complete_university_matrix[ , -6])
```


10 of 11 · Scoring and Ranking Universities
Learn
Now that we've learned to combine vectors into matrices, to extract elements, and to perform operations on matrices, let's return to our initial goal: Analyzing the university ranking data to decide on a university to attend.

To answer this question, let's develop a score for each university that is an aggregate of the rankings and tuition information available in university_matrix. We'll rank the universities for each category we have data for: world_rank, quality_of_education, influence, broad_impact, patents, and tuition. These rankings will allow us to evaluate universities across various aspects.

Then, we can calculate a score for each university from the sum of its rankings.

Let's rank each university relative to others in the dataset.
```{r}
# _          world_rank quality_of_education influence broad_impact patents tuition
# harvard             1                    1         1            1       3   43280
# stanford            2                    9         3            4      10   45000
# MIT                 3                    3         2            2       1   45016
# cambridge           4                    2         6           13      48   49350
# oxford              5                    7        12            9      15   28450
# columbia            6                   13        13           12       4   55161
```

We use the rank() function, along with an expression that indexes the matrix, to specify the category we want to rank the universities by. The rank() function returns a vector of numeric values. For example, to rank universities by quality_of_education, we'd write:
```{r}
rank(university_matrix[ , "quality_of_education"])
# output:
# harvard   stanford     MIT  cambridge     oxford   columbia
#      1          5       3          2          4          6
```

We can do it for every category we have in our dataset and store the results in variables:
```{r}
world_rank_rank <- rank(university_matrix[,"world_rank"])
quality_of_education_rank <- rank(university_matrix[,"quality_of_education"])
influence_rank <- rank(university_matrix[,"influence"])
broad_impact_rank <- rank(university_matrix[,"broad_impact"])
patents_rank <- rank(university_matrix[,"patents"])
tuition_rank <- rank(university_matrix[,"tuition"])
```

Now that we've ranked the six universities by each category, let's combine the vectors containing the ranks into a single matrix (ranks_university_matrix) using rbind():
```{r}
ranks_university_matrix <- rbind(world_rank_rank, quality_of_education_rank, influence_rank, broad_impact_rank, patents_rank, tuition_rank)
```

Note that because we used rbind(), we combined the vectors by rows. The new matrix contains the vectors for each category stacked one on top of the other. Each university's rankings are in a different column.

Now, we can calculate a score for each university. Smaller scores indicate higher rankings. Let's assume that we value every category in our university selection equally.

To calculate an aggregate score for each university, let's calculate the sum of its rankings in every category using the colSums() function.
```{r}
colSums(ranks_university_matrix)
# output:
# harvard   stanford    MIT  cambridge     oxford   columbia 
#      8         20     15         27         24         32
```

practice:
```{r}
university_matrix_avg <- colMeans(ranks_university_matrix)
```
11 of 11 · Next Steps


Lists in R
1 of 10 · Lists: Objects That Can Contain Multiple Data Types

Learning a data structure implies learning:
- To create a data structure.
- To index (i.e., accessing) data structure's elements.
- To add/remove elements from a data structure.
- To use data structures in our operations/tasks.
- In the first two lessons of this course, we learned about two different data structures:

Vectors: One-dimensional data structures that hold a single data type.

Matrices: Two-dimensional data structures that hold a single data type.

In the last lesson, we worked with matrices to analyze university rankings, which helped us take decision on the topmost university for us to attend. Now that we're about to begin our first year at Harvard, we're faced with another decision on clubs (sports, art, music, etc) to join, so that we can make friends with similar interests. This is where lists come in.

In this lesson, we'll learn how to work with data stored in lists as we organize the results of our investigation of different university clubs.

A list, is a multi-dimensional data structure which contains MULTIPLE DATA TYPE of objects. The objects may consist of single data elements (literal values), different data structures like vectors, matrices, and even other lists.

Why would we want to create lists of objects in R? The answer is that storing objects in lists allows us to make use of some very powerful R features for performing the same operation on each object in our list, which can let us avoid repetitively typing the same function.

We'll learn how to harness the power of lists for performing tasks such as those illustrated above in the next course. For now, we'll proceed with providing a strong foundation in creating, manipulating, and understanding the structure of lists.

Practice:
```{r}
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)
# add code
category_names <- c("world_rank", "quality_of_education", "influence", "broad_impact", "patents")
university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia) 
colnames(university_matrix) <- category_names
```

2 of 10 · Creating a List
Learn
On this screen, we learn how to create a list.

A list is created using the list() function. This function receives a sequence of values of ANY TYPE separated by commas (,). R then takes charge of constructing a list from those values.

In the following example, we are storing three club names in a list:
```{r}
list("tennis", "films", "outdoors")
# output:
# [[1]]
# [1] "tennis"

# [[2]]
# [1] "film"

# [[3]]
# [1] "outdoors"
```

We can also use the function c() to create a vector in the example above because all the values are of the SAME TYPE.

Let's now try to create a vector with DIFFERENT TYPES.

In the following example, we are attempting to create a vector that contains the University of Harvard's name, its rankings in every category, and if it's in the USA or not.
```{r}
c("harvard", 1, 1, 1, 1, 3, TRUE)
# Not minding the different data types, this returns a character vector:
# OUTPUT:
# [1] "harvard" "1"      "1"      "1"      "1"      "3"      "TRUE"
```

We may wonder why did that last command create a character vector? Since we are trying to create a vector of different types (character + numeric + logical), which is not allowed in R, R transforms all the values into the same type following the highest type rule, that's why all the values are of the character type.

However, if we want to preserve the different data types in the same object, we need to use the list() function like so:
```{r}
list("harvard", 1, 1, 1, 1, 3, TRUE)
# output:
# [[1]]
# [1] "harvard"

# [[2]]
# [1] 1

# [[3]]
# [1] 1

# [[4]]
# [1] 1

# [[5]]
# [1] 1

# [[6]]
# [1] 3

# [[7]]
# [1] TRUE
```

We can see that R understands each type and keeps them as such in the data structure.

Let's create a list where the rankings in the previous list are stored as a vector in the list.
```{r}
list("harvard", c(1, 1, 1, 1, 3), TRUE)
# output:
# [[1]]
# [1] "harvard"

# [[2]]
# [1] 1 1 1 1 3

# [[3]]
# [1] TRUE
```

We can also name the elements in the list like when we created named vectors. To specify names we can use =: name = the_object.
```{r}
list(name = "harvard", ranking = c(1, 1, 1, 1, 3), is_in_usa = TRUE)
# OUTPUT:
# $name
# [1] "harvard"

# $ranking
# [1] 1 1 1 1 3

# $is_in_usa
# [1] TRUE
```

practice:
```{r}
university_clubs <- list("ballroom dancing", "rugby", "bird watching", "pottery")
mit_list <- list("MIT", c(3,3,2,2,1), TRUE)
mit_named_list <- list(name = "MIT", ranking = c(3,3,2,2,1), is_in_usa = TRUE)
```


3 of 10 · Anatomy of a List
Learn
Let's look at the list of clubs we created on the previous screen:
```{r}
# output:
# [[1]]
# [1] "ballroom dancing"

# [[2]]
# [1] "rugby"

# [[3]]
# [1] "bird watching"

# [[4]]
# [1] "pottery"
```

Note that each club we stored in the list appears on its own line, and its position within the list is shown in brackets above it ([[1]] through [[4]]). This indicates the order of the objects as stored in the list.

We know that the university_clubs list contains only single elements of character data type. Recall, however, that lists may contain objects of any data type. This flexible feature allows us to use them to store other information from our club search, including club descriptions, types of activities, the cost of club dues, and the times when the club holds meetings.

Here is some of the data we've gathered for the chess club:
```{r}
club_title <- c("Chess Club")
club_description <- c("Meets two nights a week for members to play chess. Snacks are provided")
club_dues <- c(50, 20, 15)
meeting_days <- c("Monday", "Wednesday")
meeting_times <- c("6:00 pm", "8:00 pm")
```

The pieces of information we have are:

Club title (a vector of character data)
Club description (a vector of character data)
Club dues (a vector of numeric data)
Meeting days (a vector of character data)
Meeting times (a vector of character data)
Let's create a list to organize and store this data.

practice:
```{r}
club_title <- c("Chess Club")
club_description <- c("Meets two nights a week for members to play chess. Snacks are provided.")
club_dues <- c(50, 20, 15)
meeting_days <- c("Monday", "Wednesday")
meeting_times <- c("6:00 pm", "8:00 pm")

# add code
club_meetings <- rbind(meeting_days, meeting_times)
chess_club <- list(club_title, club_description, club_dues, club_meetings)
```

4 of 10 · Naming Objects in a List
Learn
On this screen, we'll learn how to give names to objects within a list in R. This can make working with lists more organized and easy to understand.

We created the list chess_club on the previous screen to organize the information we gathered about the club:
```{r}
# output:
# [[1]]
# [1] "Chess Club"

# [[2]]
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# [[3]]
# [1] 50 20 15

# [[4]]
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

When you create a list in R, the individual objects within the list are not automatically assigned names, but their original data types are retained. You can then add names to the objects, as we learned before.
```{r}
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Play matches against clubs from local universities"), club_dues = c(100, 50))

# The resulting list, rugby_club, contains three objects with names assigned to them:
# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 100  50
```

However, we're learning to use R with larger datasets and this can become very cumbersome. Instead of assigning a name to each element manually, we can use a vector of character data to assign names to objects of a list. Assigning names to list objects is similar to assigning names to vector elements using the names() accessor function.

To illustrate this, let's create a list containing data for the ballroom dancing club:
```{r}
ballroom_dancing <- list(c("Ballroom Dancing"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))

# output:
# [[1]]
# [1] "Ballroom Dancing Club"

# [[2]]
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# [[3]]
# [1] 150
```

Now, let's assign a name to each object in ballroom_dancing:
```{r}
names(ballroom_dancing) <- c("club_title", "club_description", "club_dues")
# If we display ballroom_dancing, we'll see that each object is named:
# output:
# $club_title
# [1] "Ballroom Dancing Club"

# $club_description
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# $club_dues
# [1] 150
```

As with vectors and matrices, if we call the names() function in a list without assigned names, the function returns the names's vector or NULL if there is no name.

Let's assign names to objects of the chess_club list that we created earlier.

practice:
Use the names() function to assign the chess_club_names vector as names to elements of the chess_club list.
```{r}
club_meetings <- rbind(meeting_days, meeting_times)
chess_club <- list(club_title, club_description, club_dues, club_meetings)
chess_club_names <- c("club_title", "club_description", "club_dues", "club_meetings")
# Type your code below
names(chess_club) <- c("club_title", "club_description", "club_dues", "club_meetings")
```


5 of 10 · Indexing Lists: Accessing Data in Lists
Learn
In previous lessons, we learned to index vectors and matrices to extract a subset of values. Similarly, we can index lists.

Generally, we'll use two different indexing operations on lists:

Single brackets to return a list of selected elements ([])
Double brackets to return a single element ([[]])
Let's take the rugby_club list as an example:
```{r}
# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 100  50
```

If we want to extract the second object in the list, we use single brackets [] like the following code:
```{r}
rugby_club[2]
# output:
# $club_description
# [1] "Plays matches against clubs from local universities"
```

If we check the type of the object, with the function class(), we see that it is a list:
```{r}
class(rugby_club[2])
# output:
# [1] "list"
```

Let's perform this operation using double brackets:
```{r}
rugby_club[[2]]
# the output is: [1] "Plays matches against clubs from local universities"

class(rugby_club[[2]])
# the output is: [1] "character"
```

This time, the output is a single element of the data type character.

To better illustrate when we'd choose to use single or double brackets to index a list, let's extract multiple list elements.

Recall from earlier lessons that we can extract multiple elements using c(). Let's use single brackets to extract the first and third objects in the rugby_club list:
```{r}
rugby_club[c(1,3)]
# The output consists of a list of the first and third vectors that we stored in rugby_club:
# output:
# $club_title
# [1] "Rugby Club"

# $club_dues
# [1] 100  50
```

What happens if we use double brackets to index rugby_club?
```{r}
rugby_club[[c(3,2)]]
# Now, the output consists of the second element in the third object of the list:
# [1] 50
```

When objects in a list have names associated with them, we can use them for indexing.

The following three lines of code extract the elements contained in the third object in the rugby_club list:

Using the dollar sign ($) symbol to extract elements of a named object of a list:
```{r}
rugby_club$club_dues
# the output is: [1] 100  50
```

Using the name of the object to extract in brackets:
```{r}
rugby_club[["club_dues"]]
# the output is: [1] 100  50
```

Using the position of the object to extract in brackets:
```{r}
rugby_club[[3]]
# the output is: [1] 100  50
```

PRACTICE
Let's practice indexing the chess_club list.
Here is the chess_club list:
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20 15

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

Index the chess_club list to return the fourth object, a matrix.
Store the result in the variable meeting_matrix.

Index the third object of the chess_club list, club_dues, to return the second element of that object.
Store the result in the variable club_second_due.
```{r}
meeting_matrix <- chess_club[[4]]
club_second_due <- chess_club[[c(3,2)]]
```



6 of 10 · Modifying List Elements
Learn
In addition to extracting elements, we can also change specific list components.

For example, let's say you have been informed that the club dues paid by members at the start of the fall and spring semesters have increased by 10 USD each.

As a result, we'd like to change the values of club_dues we have stored in our rugby_club list:
```{r}
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 100  50
```

To replace the club_dues values in the rugby_club list with the new costs we've learned about, here are three ways to do it:
```{r}
rugby_club[[3]] <- c(110, 60) # c(..., ...) assigning a new value
#index the third object by position (using double brackets)

rugby_club[["club_dues"]] <- c(110, 60) 
#index the third object by name (using double brackets)

rugby_club$club_dues <- c(110, 60)
#index the third object by name using '$'
```

We can replace only one of the dues values. Let's say the club captains are considering discounting the fall semester dues by 50 USD to encourage more freshmen to join this year. To replace 110 with 60, we would write:
```{r}
rugby_club[[c(3, 1)]] <- 60 
# note that here we are indexing the first element of the third object.
```

Remember that use of the double brackets here specifies the first value of the third object in the list.

Let's modify the chess_club list to reflect new information our research has turned up. Currently, chess club members pay dues during the fall semester (50 USD), spring semester (20 USD), and during summer (15 USD) if they are staying on campus. Since few students stay on campus and snack costs are low, the club captain is reducing summer club dues to 5 USD.

Here is the chess_club list:
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20 15

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

Write code to replace the third element of club_dues to 5.

Display the third element of club_dues in the chess_club list to check that the third element of club_dues has changed.
practice:
```{r}
chess_club[[c(3, 3)]] <- 5
chess_club[[c(3, 3)]]
```



7 of 10 · Appending Elements to Lists
Learn
As we continue to research clubs, we might acquire more information that we want to incorporate into our existing lists.

Since one of the reasons we're looking to join clubs is to meet new friends, we'd like to join clubs that have lots of members who are also in their first year of university.

As we researched the clubs we're interested in, we found some information on the number of first-, second-, third-, and fourth-year university students who participated in the club during fall and spring semesters last year.

For the rugby club, we organized the information in the form of numeric data in a matrix named member_years_rugby:
```{r}
fall <- c(8, 12, 13, 2)
spring <- c(6, 11, 14, 3)

member_years_rugby <- rbind(fall, spring)
colnames(member_years_rugby) <- c("first_yr", "second_yr", "third_yr", "fourth_yr")

print(member_years_rugby)

# output:
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3
```

We'd like to add this matrix as an object to the rugby_club list, which currently contains three objects:
```{r}
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 80 60
```

Let's add member_years_rugby as a fourth object of the list. To add an element to a list, we can specify the position we want the new element to occupy using double brackets:
```{r}
rugby_club[[4]] <- member_years_rugby

# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 80 60

# [[4]]
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3
```

Let's make three important points here:

The new object we added is placed at the end of the rugby_club list.
The object is numbered in the list and not named since we used position indexing.
The object would overwrite an existing object if instead of specifying a new position, we specified an existing one (remember the previous screen where we modified an existing object in a list).
As we've seen above, objects added to a list do not have names associated with them unless we specify them.

We could assign a name to the object as we learned earlier in this lesson. If we want to append member_years_rugby to rugby_club and give it a name, we would write:
```{r}
rugby_club[["members_years_rugby"]]
member_years_rugby
```

Let's clarify the process here:

The new object is added at the end of the list without requiring us to indicate the current end of the list (contrary to when we use positions indexing like above).
A name is assigned to this object in the list.
We've researched chess club membership and found the following numbers of first-year members that joined during the fall and spring semesters last year:

Fall Semester: 12
Spring Semester: 15
Let's add this information to our chess_club list.


Practice
Instruction:
We have created a vector, first_years, that contains the number of first-year chess club members for last year's fall and spring semesters.

Add the first_years vector as an object, of the same name, to the end of the chess_club list.

Index chess_club to display the number of first-year students that participated in chess club during last year's spring semester.
```{r}
first_years <- c(12, 15)
names(first_years) <- c("fall", "spring")
# add code
chess_club[["first_years"]] <- first_years
chess_club$first_years[[2]]
```


8 of 10 · Removing Elements from a List
Learn
On this screen, we'll investigate how to remove elements from a list. Similar to removing elements from a vector by indexing them negatively, we can apply the same technique to remove elements from a list.

Let's demonstrate this using the chess_club list.
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20  5

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

We can remove values from a list by specifying their position preceded by a minus symbol (-) in square brackets ([]); not double square brackets. To remove the object in the second position of chess_club, we can write:
```{r}
chess_club[-2]
# output:
# $club_title
# [1] "Chess Club"

# $club_dues
# [1] 50 20  5

# $club_meetings
# _             [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

We can also remove multiple objects from a list by specifying more than one position preceded by a minus symbol (-) in square brackets ([]). To remove elements in the first and third position from the chess_club list, we would write:
```{r}
chess_club[c(-1, -3)]
# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_meetings
# _             [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"
```

PRACTICE
The chess_club list is available from previous screens. Here is its content:
```{r}
# $club_title
# [1] "Chess Club"

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."

# $club_dues
# [1] 50 20  5

# $club_meetings
#              [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"  

# $first_years
#  fall spring 
#    12     15
```

Write code to remove the first object of the list, chess_club.

Store the result in the variable chess_club_without_1.
Write code to remove the object at the third and fourth positions of the chess_club list.

Store the result in the variable chess_club_without_34.
```{r}
chess_club <- list("club_title" = c("Chess Club"), 
                   "club_description" = c("Meets two nights a week for members to play chess. Snacks are provided."), 
                   "club_dues" = c(50, 20, 15), 
                   "club_meetings" = rbind(c("Monday", "Wednesday"),  c("6:00 pm", "8:00 pm")),
                   "first_years" = c("fall" = 12, "spring" = 15))

# add code

chess_club_without_1 <- chess_club[-1]
chess_club_without_34 <- chess_club[c(-3, -4)]
```


9 of 10 · Combining Lists
Learn
In this lesson, we've been creating lists of data for several clubs:

rugby_club
ballroom_dancing
chess_club
Perhaps we'd like to combine them into a single list.

The syntax for combining multiple lists is similar to that of combining vectors. To combine the rugby_club and ballroom_dancing lists into a new list called university_club_data, we can use the c() function:
```{r}
university_club_data <- c(rugby_club, ballroom_dancing)
# output:
# $club_title
# [1] "Rugby Club"

# $club_description
# [1] "Plays matches against clubs from local universities"

# $club_dues
# [1] 80 60

# $member_years_rugby
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3

# $club_title
# [1] "Ballroom Dancing Club"

# $club_description
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# $club_dues
# [1] 150
```

Combining lists using c() appends lists to one another, end-to-end, to create a single list. We can use it to combine as many lists as necessary.

The university_club_data list is confusing because some of the elements, like club_description, have the same name. We need a way to combine lists that preserve the organization of each list.

Recall that lists can contain any type of data object, including other lists. Instead of combining elements of the three lists into a single list as we did using c(), we can use the list() function to create a new list of lists. Let's create a list of lists, university_club_list, to illustrate how this works.

Recall the syntax for creating a list of named objects from earlier in this lesson:
```{r}
universty_club_list <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing)
# output:
# $rugby_club
# $rugby_club$club_title
# [1] "Rugby Club"

# $rugby_club$club_description
# [1] "Plays matches against clubs from local universities"

# $rugby_club$club_dues
# [1] 80 60

# $rugby_club[[4]]
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3

# $rugby_club$member_years_rugby
#       first_yr second_yr third_yr fourth_yr
# fall          8        12       13         2
# spring        6        11       14         3


# $ballroom_dancing
# $ballroom_dancing$club_title
# [1] "Ballroom Dancing Club"

# $ballroom_dancing$club_description
# [1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

# $ballroom_dancing$club_dues
# [1] 150
```

Notice that the name of each object in university_club_list follows the name of the list it belongs to (either rugby_club or ballroom_dancing), making it much clearer and organized.

Creating a list of lists will be a technique we use when we want to perform the same operation on multiple lists at the same time in future courses.

For now, let's practice by creating a list of the three lists of club data we've worked with in this lesson.
```{r}
university_clubs <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing, chess_club = chess_club)
```

10 of 10 · Next Steps


Dataframes in R
1 of 10 · Introduction
Learn
Throughout this course, we've learned about different data structures available to us in R. Matrices and their use for storing numbers in an organized structure, and how lists are useful for keeping data of different types together in the same data structure. As we approach the end of this course, we're now going to focus our attention on another very essential data structure, tabular data.

Tabular data is data organized into rows and columns. If you've ever worked with data from Microsoft Excel, Google Sheets or a humble comma separated value file (CSV), then you've already been exposed to some form of tabular data. In tabular data, a single row represents information on a single thing or entity. This information is divided up into distinct columns. As we stack rows together, we get a rectangle of data, or table, that gives tabular data its name. 

As you can see, each row contains information about a single person, and this information is subdivided into each of their names, grades, hobbies and their language of preference. The spot where a single row and single column meet is called a cell. Notice that each cell contains just a single characteristic about a single person. Each column can have its own data type as well. We can see that the name and hobby columns contains strings, grade contains numbers and prefers_R contains logicals.

In R, the tidyverse packages have a special way to handle tabular data called a tibble. Tibbles are like data frames, but with added functionality that makes them easier to work with. The difference between a tibble and a data frame is that tibbles are compatible with all of the packages associated with the tidyverse. As we'll learn more throughout this lesson, we can create elegant and easy-to-read R code using tibbles and the tidyverse. Tibbles also help streamline the process of data analysis and make you an even more effective R programmer. Let's get to learning!



2 of 10 · Getting Familiar With The Data
Learn
For this lesson, we'll be working with a dataset containing information on the earning potential of various college majors. The dataset contains information such as the number of people surveyed for the data, the median salary of people who took the major, and employment rates of graduates. As we learn more about how to manipulate tibbles, we'll use this dataset to practice the concepts and functions that you learn.

In our Introduction to R course, we learned about the read_csv() function from the readr package, which allows us to read in CSV files into our R session. Assuming that the name of the dataset was recent_grads.csv and that it was in our working directory, we can read the data into a variable recent_grads using the following code:
```{r}
library(readr)
recent_grads <- read_csv("recent_grads.csv")
```

After bringing in the readr package, we have access to all of the functions in it, thereby making the read_csv() function available for us to use.

Now that we have our data in a variable called recent_grads, we can inspect it directly in the "Variables" section of the Dataquest code editor. Since we read in a CSV file, we know that we're working with tabular data. If we try to look at recent_grads directly in RStudio, we'll find that it's actually imported as a tibble!
```{r}
# > recent_grads
# A tibble: 173 x 18 # More output follows, but is shortened
```

But you'll have to take our word for it, because the dataframe output looks different in the Dataquest user interface.

Recall that when we use the read_csv() function, R returns a dataframe containing our dataset and then, tries to identify the correct data types of each column. A message is thereby displayed at the end of the process to let us know the data type chosen for each column. This message is not an error. It is worth reading this message to learn about the columns in the dataframe making sure that each column has the right type. In this case, the output looks like this:

Parsed with column specification:
cols(
  Rank = col_double(),
  Major_code = col_double(),
  Major = col_character(),
  Total = col_double(),
  Men = col_double(),
  Women = col_double(),
  Major_category = col_character(),
  Sample_size = col_double(),
  Employed = col_double(),
  Full_time = col_double(),
  Part_time = col_double(),
  Full_time_year_round = col_double(),
  Unemployed = col_double(),
  Unemployment_rate = col_double(),
  Median = col_double(),
  College_jobs = col_double(),
  Non_college_jobs = col_double(),
  Low_wage_jobs = col_double()
)


The first thing any data analyst should do before carrying out any sort of analysis is to become familiar with the available dataset. This involves many things, but we should be focused on answering the following questions first:

What are the column names of the data?
What are the data types of each column?
How many rows are in the data? Columns?

There are many ways that we can get the answers to these questions, but we'll explore a few different methods. If we just wanted to get a quick summary of the data itself, we can use the glimpse() function from the tibble library. The glimpse() function will help answer all three of the above questions for us. We show a truncated version of the function output below.
```{r}
# > glimpse(recent_grads)
# Observations: 173
# Variables: 18
# $ Rank  1, 2...
# $ Major_code  2419, 2416...
# $ Major  "PETROLEUM ENGINEERING", "MINING AND MINERAL ENGINEERING"...
```

Important note: To view the output of glimpse() in the Dataquest editor, we've added the function argument col_types = cols() in the display code to suppress the read_csv() column specification message described above.

The number of "Observations" corresponds to the number of rows in the dataset, while the number of "Variables" tells us the number of columns. After these numbers, we see each of the variables/columns in more detail, including the column name, its type and a small sample of the values contained in the column. For example, the Rank column is the first column in the data and contains numbers in the form of doubles (dbl). Since each row represents a major, the Rank column represents the ranking of each major. Knowing the column names and types is important because it allows us to filter and choose subsets of the data.

One weakness of the glimpse() function is that it's purely for reading. There are times where we might actually need the number of rows or columns to store in a variable. If we want to do this, we would need to use the nrow() or ncol() functions, respectively. Both of these functions can take in a tibble and they output the number of rows/columns.

```{r}
nrow(data) # returns the number of rows in `data`
ncol(data) # returns the number of columns in `data`
```

If we want to get just the column names of the data itself, we can use the names() function. Like nrow() and ncol(), names() can take in a tibble and return the column names of the tibble.

PRACTICE
```{r}
library(tidyverse)
# Supply col_types = cols() to suppress column specification output 
recent_grads <- read_csv("recent_grads.csv", col_types = cols())
glimpse(recent_grads)
names(recent_grads)

num_rows <- nrow(recent_grads)
num_cols <- ncol(recent_grads)
```

Dataframes in R
3 of 10 · Selecting Columns
Learn
Now that we're more familiar with the recent_grads data, we can start manipulating it so that we can use it for data analysis later. In general, most analyses won't need all of the columns of a dataset. In these situations, it's good practice to pare down the data to just the columns that you need.

To filter the data by columns, we can use the select() function which comes from the dplyr library. Notice that this is also a tidyverse library. The select() function takes a varying number of arguments since it doesn't know ahead of time how many columns a programmer may need from it. The first argument that the select() function takes is a tibble, and the following arguments are column names that are in the tibble. An example follows using the recent_grads dataset:
```{r}
filtered_data <- select(recent_grads, Rank, Major)
```

The above code took in the recent_grads tibble and used the select() function to pick out two columns from it, Rank and Major. The filtered data is then assigned to the variable filtered_data. We can specify as many columns as we want to keep in the select() function, as long as they are actually present in the tibble.

The select() function can also be used to remove columns from a dataset. The syntax is similar to keeping columns, with a minor tweak. The code below removes one column from the data:
```{r}
filtered_data <- select(recent_grads, -College_jobs)
```

When we use a - ("minus sign") before a column name, we're actually telling the select() function that we want to remove that column. This is very useful when there are many columns in the dataset because, it would be cumbersome to write the names of so many columns if we were picking columns to keep. Instead of doing this, it's faster to remove columns that we don't want. In general, you're only going to do one action in the select() function: either pick columns to keep or remove columns you don't want. It wouldn't make sense to try to do both in the same select() function.

With this in mind, let's practice using the select() function on recent_grads.
PRACTICE
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

rank_major_tibble <- select(recent_grads, Rank, Major)
no_major_code_tibble <- select(recent_grads, -Major_code)
```


Dataframes in R
4 of 10 · Filtering Rows
Learn
On the last screen, we learned how to pick columns from the data using the select() function. In this screen, we'll learn the corresponding filter function to choose rows that we want to keep in the data.

There are many reasons why we would want to filter out particular rows in our data. Using our recent_grads data as an example, perhaps we have to do an analysis that only involves majors with more than 1000 people. Perhaps there is some missing data in one of the rows, and we want to remove them. In both of these cases, we need some specific conditions to filter out the rows.

Recall that each of the rows represents information on a single thing (or in this case, major), so filtering the rows means looking for a subset of the rows that have a particular quality.

Like the select() function, the filter() function first takes in a dataset, followed by conditions on columns that we want to use to filter. Below is an example use of the filter() function on the recent_grads data.
```{r}
top_100_majors <- filter(recent_grads, Rank < 100)
```

If we had multiple conditions, then we would separate them using commas:
```{r}
large_engineering_majors <- filter(recent_grads,
                                   Total > 5000,
                                   Major_category == "Engineering")
```

The above code filters the Total column using a number and the Major_code column using a string. It wouldn't make sense for us to filter a numerical column with a string or vice-versa, which is why it's important for us to know about the data types for all of our columns.

Notice too that we've broken up the function into different lines, based on the commas. We could still have everything on one line, but it's good practice to keep one line from getting too long. We can now clearly differentiate between the different conditions, which makes for more readable code.

Since the filter() function requires some kind of conditions, we need to understand comparison operators. This is just a fancy name for the symbols we use to compare objects. We'll learn more about comparison operators in the next lesson, but knowing how to use the operators below will be enough for this lesson.

column == a: equality, "Filter for where the column equals 'a'"
column != b: not equals, "Filter for where the column is not 'b'"
column < 5: less than, "Filter for where the column is less than 5"
column <= 5: less than or equal, "Filter for where the column is less than or equal to 5"
column > 10: greater than, "Filter for where the column is greater than 10"
column >= 10: greater than or equal, "Filter for where the column is greater than or equal to 10"

With these comparison operators in mind, practice using the filter() function to make your own subsets of the data.


PRACTICE

Filter the recent_grads data for those with a Sample_size value greater than 100. Assign this filtered tibble to the variable large_sample_majors.
Filter the recent_grads data:
Where Total is less than or equal to 70,000
Where Median is greater than 40,000
Where the Major_category isn't Engineering
Assign this tibble to the variable non_engineering_majors.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())



large_sample_majors <- filter(recent_grads, Sample_size > 100)
non_engineering_majors <- filter(recent_grads, 
                                 Total <= 70000, 
                                 Median > 40000, 
                                 Major_category != "Engineering")
```


Dataframes in R
5 of 10 · Piping With The %>% Operator
Learn
So far in this lesson, we have taken tibbles and passed them into either the select() function or the filter() function to get a subset of the same tibble. Both of these functions return an altered version of the original tibble. Let's say that we want to filter both rows and columns of a particular tibble, which means we want to combine the select() function and filter() functions. We might write this code out like this:

```{r}
ranked_majors <- select(recent_grads, Rank, Major, Total)
low_total_ranked_majors <- filter(ranked_majors, Total < 2000)
```

In the code above, we create a new variable ranked_majors that contains three columns picked from recent_grads. After this, the ranked_majors tibble is fed into the filter() function and is assigned to another new variable low_total_ranked_majors.

There's nothing wrong with this approach, but imagine a scenario where there are multiple data manipulation steps we need to take. Each step creates a new tibble, assign it to a new variable and then pass this variable into a new function. This creates a situation where we're creating a lot of tibbles that are just used once, and we have to keep track of all these new variables.

The tidyverse provides us with a beautiful tool that will allow us to streamline this process and do all of our data manipulation in one place. That tool is the %>% function, named the pipe operator. The pipe operator allows us to chain data manipulation functions together, that is to take the output of one function and use it directly as the input of another function. In terms of code, we can rewrite the above using %>%:
```{r}
low_total_ranked_majors <- recent_grads %>% 
  select(Rank, Major, Total) %>%
  filter(Total < 2000)
```

The two code blocks produce exactly the same result, but the %>% operator allows us to better see the flow of our data manipulation. In the first line of the new code, the recent_grads tibble is piped into the select() function. Similarly, the output of select() is passed into the filter() function, where the pipeline ends.

Using the %>% operator, we only need to create one new variable, and we are able to have our entire data manipulation pipeline into one place. This is extremely powerful for code readability and simplification. Less variables means less room for errors down the line, and more readable code means less time spent trying to understand what it's trying to do. We encourage you to use piping as you learn more about R and the tidyverse.

The code we've used so far uses %>% in the context of tibbles, but we can also use it with any data structures of variables that we have in R! We'll demonstrate this below:
```{r}
# Old way of summing a vector
sum(c(1, 2, 3, 4, 5))
# [1] 15

# "Piping" the vector into the sum function
c(1, 2, 3, 4, 5) %>% sum()
# [1] 15

# Old way of printing a string in the R console
print("Learning about the pipe!")
# [1] "Learning about the pipe!"

# "Piping" a string into the print function
"Learning about the pipe!" %>% print
# [1] "Learning about the pipe!"
```

Incorporating the %>% operator into your code may take some adjustment, but it will greatly increase the readability and speed of your coding. Get some practice using it below.

PRACTICE
Starting with the recent_grads tibble, create a pipeline using %>% that does the following:
Removes the Rank and Major columns and
Filters for majors with a Median pay less than 50000
Finally, assign the output of this pipeline to the variable pipeline_output.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

pipeline_output <- recent_grads %>%
  select(-Rank, -Major) %>%
  filter(Median < 50000)
```


Dataframes in R
6 of 10 · Creating New Columns
Learn
Now that we know how to filter our tibbles down based on row or column, we can move onto a new method of manipulating our data. Once we've filtered our data down to what we need, the next step is often to create new columns from the existing data.

One common example of creating new data from existing columns is converting counts into percentages. In the recent_grads data, we have a Total column (total number of surveyed people with the major) and a Men column (number of males). These numbers by themselves don't tell us much since the Totals vary so much, but if we create a new column based on percentages, this will allow us to better compare majors.

In order to create a new column based on other columns, we need to use the mutate() function. Within a mutate() function, we name new columns and define how they should be calculated. For example, we can do the following:
```{r}
new_recent_grads <- recent_grads %>%
  mutate(
    prop_male = Men / Total,
    prop_male_gt_half = prop_male > 0.5
  )
```

The result of the code is another new tibble new_recent_grads that contains all of the data that recent_grads has, with two additional columns prop_male and prop_male_gt_half. The mutate() function is what creates both of these new columns.

To make the prop_male column, the mutate() function takes the Men value and divides it by the Total value for each row. It does this for each row and assembles prop_male with all these values.

The second new column prop_male_gt_half gets constructed in a similar manner, but it actually uses prop_male. We're allowed to reference new columns in the mutate() function, which is what makes it so powerful. All of the rows in prop_male are compared to the value 0.5. If they're greater, prop_male_gt_half will be TRUE and FALSE otherwise.

Now that you've learned about the mutate() function, get some practice making new columns in recent_grads.


PRACTICE
Create three new columns in recent_grads and assign the result to the variable new_recent_grads:

One column should be called prop_employed, and it should be the proportion of people employed by major.
The second new column should be called prop_women, and it should be the proportion of women in the major.
The final column should be called prop_women_gt_employed, and it should be a logical column where the proportion of women in the major is greater than (>) the proportion of people employed by major.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

new_recent_grads <- recent_grads %>%
  mutate(
      prop_employed = Employed / Total,
      prop_women = Women / Total,
      prop_women_gt_employed = prop_women > prop_employed
      )
```


Dataframes in R
7 of 10 · Sorting Data
Learn
After creating columns of interest, it's good practice to reexamine the data to see if it is accurate and matches your expectations. Sometimes mistakes will be made in calculations, and it's better to catch them early.

Let's say that we're not sure if the prop_male column we calculated came out correctly. We would expect the higher values of prop_male to have either high numbers of Men, low Total or both. To examine this, we need to sort the data based on the prop_male column in descending order and examine the first few values.

The arrange() function can help us with that. This function takes in one or more columns that we want to sort the tibble by. Taking the example from the last screen, we can sort by prop_male by doing the following:
```{r}
new_recent_grads <- recent_grads %>%
  mutate(
    prop_male = Men / Total
  ) %>%
  arrange(-prop_male) %>%
  select(Total, Men, prop_male)
```

By default, the arrange() function sorts things into ascending order. If we were just to supply prop_male by itself to arrange(), then the tibble would start with the row with the smallest value. To reverse this, we just need to add a - sign to the beginning of the column name to indicate sorting in descending order.

If we supply multiple columns into the arrange() function, then the data will be sorted from left to right. That is to say, after sorting on the first column, the arrange() function will perform subsorts based on the columns that come after it.

Now we can have a quick look at new_recent_grads to prove to ourselves that the calculation was correct. Using the head() function, we can view the first few rows:
```{r}
# output:
# > head(new_recent_grads)
## A tibble: 6 x 3
#  Total   Men prop_male
        
# 1   124   124     1    
# 2  4790  4419     0.923
# 3 18498 16820     0.909
# 4   756   679     0.898
# 5  1258  1123     0.893
# 6 91227 80320     0.880
```

The major with the highest proportion of men is entirely male, which fits our intuition about what the column needs to represent. Using the above code as an example, try to answer this analytical question about the recent_grads data.

PRACTICE
What major has the lowest proportion of employed graduates?

Assign your answer to the variable least_employed_major.
Enter your answer exactly how it appears in the data.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

least_employed_major <- recent_grads %>%
  mutate(
    prop_employed = Employed / Total
  ) %>% 
  arrange(prop_employed) %>% 
  select(Major, Employed, Total, prop_employed)
    
head(least_employed_major)

least_employed_major <- "MILITARY TECHNOLOGIES"
```

Dataframes in R
8 of 10 · Summarizing Data
Learn
In the last screen, we inspected a tibble visually after doing some sorting. While visual inspection is useful in a lot of situations, it's better used for quick glances and checks.

In other cases, we'll want to gather some summary statistics to get a better understanding of our data. Instead of calculating these by hand, we can use the summarize() function to get these values with a short line of code. For example, if we want to see what the average unemployment rate was across the majors:
```{r}
summary_table <- recent_grads %>%
  summarize(
    avg_unemp = mean(Unemployment_rate),
    min_unemp = min(Unemployment_rate),
    max_unemp = max(Unemployment_rate)
  )
```

A common theme among the functions we've learned in this lesson is that they all produce tibbles, and the same applies to the summarize() function. Inspecting summary_table in the console produces:
```{r}
# output:
# > summary_table
## A tibble: 1 x 3
#  avg_unemp min_unemp max_unemp
                
# 1    0.0682         0     0.177
```

The summarize() function is often combined with the group_by() function which allows splitting the dataframe into several subsets on which we can apply functions. This workflow is known as split-apply-combine workflow and it is widely used in data analysis. It consists in three steps:

1. Split: The dataset is divided into subsets using the function group_by().
2. Apply: Within each subsets, we apply functions like the summarize() function to gather summary statistics.
3. Combine: We combine the results back together using the summarize() function again. THis now produces a summary table.

In the above example, we can introduce the group_by() function to summarize the dataframe by Major_category.
```{r}
summary_by_Major_category <- recent_grads %>%
  group_by(Major_category) %>%
  summarize(
    avg_unemp = mean(Unemployment_rate),
    min_unemp = min(Unemployment_rate),
    max_unemp = max(Unemployment_rate)
  )

# display the first three rows
head(summary_by_Major_category, 3)
```

PRACTICE
1. Create a new tibble called minmax_median_income that calculates the minimum and maximum value in the Median column.
Assign the minimum value the column name min_income.
Assign the maximum value the column name max_income.

2. Create a new tibble called minmax_median_income_by_major that calculates the minimum and maximum value in the Median column grouping by the Major column.
Assign the minimum value the column name min_income.
Assign the maximum value the column name max_income.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

minmax_median_income <- recent_grads %>%
  summarize(
      min_income = min(Median), 
      max_income = max(Median)
  )

minmax_median_income_by_major <- recent_grads %>%
  group_by(Major) %>%
  summarize(
      min_income = min(Median), 
      max_income = max(Median)
  )
```


Dataframes in R
9 of 10 · Using Tibble Columns As Vectors
Learn
As we wrap up this lesson, we'll cover one last function that will prove useful in your data analysis tasks. There are times where we'll want to isolate a column from a tibble and use it as a vector so that we can perform some operations on it such as calculatings sums and averages, as we would any other vector. We will use summing up values as an example on this screen.

There are 3 ways to do this, one of which we will recommend over the others.

The first way we can use a tibble column as a vector is through the $ (read as "dollar sign") notation. The syntax for this is [tibble]$[column_name], and we'll use it to get the Sample_size column from the recent_grads tibble:
```{r}
sample_sizes <- recent_grads$Sample_size
sample_sizes %>% sum
# output:
# [1] 61602
```

We use $ notation to "pull" the Sample_size column from recent_grads and store it into the sample_sizes variable. By using $ notation, sample_sizes now acts as a vector, so we can pipe it into the sum() function. We could have also just coded it as recent_grads$Sample_size %>% sum, but we wanted to show that these results can be stored into variables as well.

If there's whitespace in a column name, then we are unable to use the $ notation. For example, let's create a tibble named my_data with a column named "Income Level" that contains income categories:
```{r}
# Create a sample tibble with a column containing whitespace in its name
my_data <- ("Income Level" = c("Low", "Medium", "High"), Amount = c(100, 200, 300))

# Attempting to access a column with whitespace using $
my_data$Income Level

# output
# Error: unexpected symbol in "my_data$Income Level"
```

This is so because the column contains whitespace and is NOT suitable for the the $ notation.

The second way we can use a tibble column as a vector is through double-bracket [[ ]] notation. The syntax for this is [tibble][["column_name"]].
```{r}
sample_sizes <- recent_grads[["Sample_size"]]
sample_sizes %>% sum
# output: 
# [1] 61602
```

Notice that the column name must be contained in quotes. This is what allows the double-bracket method to account for columns with whitespace in it. Let's illustrate this with the sample tibble my_data we created earlier:
```{r}
my_data[["Income Level"]]
# output: [1] "Low" "Medium" "High"

```

The final way that we can use a tibble column as a vector is through the pull() function. This is the way we recommend that you use columns as vectors from here on out.
```{r}
sample_sizes <- recent_grads %>% pull(Sample_size)
sample_sizes %>% sum
# output:
# [1] 61602
```

We recommend using the pull() function over $ or double-bracket notation because it flows better with the %>% operator and increases readability. Get some practice using the pull() function before you wrap up this lesson.

PRACTICE
1. Using the pull() function, take the Median column from recent_grads dataset and assign it to the variable medians.
2. Using the max() function, find the highest value that is present in the medians variable and assign it to the variable highest_median.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

medians <- recent_grads %>% pull(Median)
highest_median <- medians %>% max
```

Dataframes in R
10 of 10 · Next Steps


Control Flow in R
1 of 10 · Introduction
Learn
In the last two lessons, you were introduced to R and the tidyverse way of programming. R is one of the most widely used programming languages in data analysis, and you've started to produce readable, analysis-ready code. We've learned about the basic data types and data structures in R, which provide you with necessary skills to import datasets into R, so that you can start manipulating them. These are excellent first steps in the journey to be a career-ready analyst.

Developing yourself as a programmer and analyst means being exposed to more tools that you can use in future data analysis tasks. These tools can come in the form of mastering programming concepts or applying functions that may perform a specific task. As you master more tools, you will be able to tackle more analysis tasks and be more flexible as a programmer. A good analyst knows the basic functions needed to solve a problem, but a great one can come up with multiple ways to approach it. In this course, we will learn more programming concepts and functions that will allow us to tackle more problems.

In this lesson specifically, we'll tackle the concept of control flow and see how it is used in a data analysis context. Control flow is just a technical term for something we do in everyday life: decision making. Imagine going to a supermarket to get some fruit for yourself. As you walk into the produce section, you find your favorite fruit: apples. When picking fruit to buy, we normally want to buy apples that look juicy and healthy and avoid fruit that looks rotten or bruised. As we pick up apples and inspect them, we are actually using control flow.

We are using different characteristics of the apples to guide our purchasing. This concept of guiding decisions also appears in programming, where we may need to use different code for different situations. This is the essence of control flow in programming in general. On the next screen, we will prepare ourselves on how to understand and use control flow in R.


Control Flow in R
2 of 10 · Review of Comparison Operators
Learn
On the last screen, we imagined a sort of decision tree on how to make a decision on buying an apple from the supermarket

In order to move through this decision tree, we need to answer either "Yes" or "No" to each question. A series of "Yes" answers will lead us through the decision process to buy a given apple. As you might recall from our Introduction to R course, R has a dedicated data type to represent the idea of "Yes" and "No: the logical data type, otherwise known as TRUE and FALSE.

In order to use control flow, we need to create statements that will turn out to be either TRUE or FALSE. In the apple example, the questions "Does the apple look fresh?" and "Is the apple big enough?" are the statements that yield TRUE ("Yes") or FALSE ("No"). In R, the most fundamental way to evaluate something as TRUE or FALSE is through the use of comparison operators. In one of our previous lessons, we had learned about Tibbles and we were introduced to comparison operators that allowed us to filter a tibble's rows based on a given comparison. The filter() function kept all rows where the comparison operator was TRUE for the row.

The filter() function applies the comparison operator to an entire column, but we can also use comparison operators for single values. Take for example the statement x < 5, where x can be some variable that we assign. If x were in fact less than 5, then the statement x < 5 would evaluate to TRUE and FALSE otherwise.
```{r}
x = 4
x < 5
# output:
# [1] TRUE

y = 6
y < 5
# output:
# [1] FALSE
```


Recall that we learned six essential comparison operators while learning how to work with tibbles. We'll use them more throughout this lesson:

== means equality. The statement x == a means "Does the value of x equal the value of a?"
!=: means "not equal". The statement x != b means "Does the value of x not equal the value of b?"
<: means "less than". The statement x < c means "Is the value of x less than the value of c?"
<=: means "less than or equal". The statement x <= d means "Is the value of x less or equal to the value of d?"
>: means "greater than". The statement x > e means "Is the value of x greater than the value of e?"
>=: means "greater than or equal". The statement x >= f means "Is the value of x greater than or equal to the value of f?"

We'll learn more comparison operators as we progress through the course, but these six are crucial to know as we move to our first example of control flow: the if statement. You can use this screen to practice using these different comparison operators.



Control Flow in R
3 of 10 · The if statement
Learn
On the last screen, we did a quick review of comparison operators. They provide us with ways to create R statements that evaluate either to TRUE or FALSE, in the same way that "Yes" and "No" allowed us to move through the decision tree of purchasing an apple. Here, we will learn how to create this branching path through the if statement.

We show an example case of an if statement below:

```{r}
major <- "Engineer"
if (major == "Chemistry") {
  print("This person majored in Chemistry.")
} else {
  print("This person did not major in Chemistry.")
}
# output:
# [1] "This person did not major in Chemistry."
```

When we start running code, R starts with the top line: major <- "Engineer". After storing that string to the variable major, R will see the if statement and will check the condition major == "Chemistry". Since major is "Engineer", this comparison operator will evaluate to FALSE. Since the condition is false, R will skip the code that will print "This person majored in Chemistry.", and it will jump to the second statement that prints "This person did not major in Chemistry."

Using a slightly different formatting, the if statement has this particular structure:
```{r}
if (condition) { 
    # If condition is true, run this code 
} else { # If condition is false, then, run this code 
}
```

The essential characteristic of the if statement is that it helps us create a branching path in our code. Both the if and the else keywords are followed by curly brackets { }, which define code blocks. Each of the code blocks represent one of the paths shown in the diagram. R does not run both, and it uses the comparison operator to decide which code block to run.


PRACTICE

The recent_grads data is available to us. Using this data:
Write an if statement that creates a new variable data_size. If the number of rows in recent_grads is greater than 1000, then data_size should be equal to "Large". If not, then data_size should be equal to "Small".
```{r}
library(tidyverse)
# Supply col_types = cols() to suppress column specification output
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

if (nrow(recent_grads) > 1000) {
  data_size <- "Large"
} else {
  data_size <- "Small"
}
```



Control Flow in R
4 of 10 · The if_else() Function
Learn
On the last screen, we learned about the if statement and its ability to create branching paths in our code. A single if statement is useful for handling one condition, but it's not useful in cases where there are a lot of values that need comparison.

For example, let's say that we want to create a new column in the recent_grads dataset that helps us to know whether or not a major was associated with Engineering. We have the Major_category column that contains information on the majors, but we need some way to vectorize the if statement to all of the values in this column. A single if statement won't be able to handle this.

Thankfully, the dplyr library within the tidyverse has such a function: the if_else() function. Here's an example of how it works:
```{r}
new_recent_grads <- recent_grads %>%
  mutate(
    is_engineering = if_else(Major_category == "Engineering", TRUE, FALSE)
  )
```

In the above code, we are creating a new column is_engineering based on the values of the Major_category column. For each row, the if_else() function takes the value in Major_category and checks if it is equal to the string "Engineering". If that row's Major_category value is "Engineering", then the corresponding "is_engineering" value will be TRUE. If not, then it will be FALSE. The if_else() function takes that single comparison operator Major_category == "Engineering" and vectorizes it.

To effectively use the if_else() function, you need to provide three arguments:

A statement (e.g. comparison operator) that evaluates to TRUE or FALSE. Instead of passing it a single value, you need to give it a specific column in the data.
The value that the new column should take if the comparison operator is TRUE. In this case, we also want the column to be TRUE, but it can be any single value that we would want it to be.
The value that the new column should take if the comparison operator is FALSE. Like the second argument, it can be anything you specify.
The if_else() function is a potent function to use in data analysis. It allows us to use if statements and apply them to our data as a whole in a single line. Take some time to practice using the function before moving forward.


PRACTICE
Using the recent_grads data:

Create a new column median_level in the recent_grads data. If Median is greater than 50000, then median_level should take the value "Above Average". If not, then median_level should take the value "Below Average".
Create another new column called greater_prop_gender. If the value in the Women column is greater than the Men column, then greater_prop_gender should be "Women". If not, then greater_prop_gender should be "Men".
The tibble with these two columns should be assigned to a new tibble called new_recent_grads.

```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

new_recent_grads <- recent_grads %>%
  mutate(
    median_level = if_else(Median > 50000, "Above Average", "Below Average"),
    greater_prop_gender = if_else(Women > Men, "Women", "Men")
  )
```

Control Flow in R
5 of 10 · Moving Beyond Two Branches
Learn
So far in our course, we've worked under the assumption that each of the decisions in our tree had only two branches: one corresponding to TRUE and another to FALSE. There are plenty occasions where we have more than two since some decisions don't boil down to a "Yes" vs "No". Let's expand our apple example to include a case with three branches.

R provides a way to handle more than two branches in an if statement with the else if keyword. The else if keyword provides another code block to use in an if statement, and we can have as many as we see fit. An example follows:
```{r}
if (color == "Yellow") {
  purchase <- TRUE
} else if (color == "Green") {
  purchase <- FALSE
} else if (color == "Red") {
  purchase <- FALSE
} else {
  purchase <- FALSE
}
```

The above code recreates the three-branched illustration. Each potential apple color gets its own branch and associated code block. The else code block helps cover us for any other potential color that we might have missed in the diagram. Without the else keyword, the purchase variable never gets assigned a value.

Using the above code as a model, get some practice creating multi-branch if statements. 

PRACTICE
We are given a variable that contains information on how many words we can write per minute: wpm. Using this variable, create a new variable classification that describes our pace with a single word.
- If wpm is less than 58, assign "Below Average" to classification.
- If wpm is greater than 82, assign "Above Average" to classification.
- Otherwise, assign "Average" to classification.
```{r}
wpm <- 70
classification <- if (wpm < 58) {
    classification <- "Below Average"
    } else if (wpm > 82) {
    classification <- "Above Average"
    } else {
    classification <- "Average"
    }


# output:
# classification
# character(character)
# [1] "Average"

# wpm
# numeric(double)
# [1] 70
```

Control Flow in R
6 of 10 · Using Multiple Conditions
Learn
As of now, we have only been using one condition in our if statements. There will certainly be times where you'll need to apply more than one condition to a branch to be more specific, catch more detailed cases, etc. In order to use multiple conditions, you'll need to familiarize yourself with the concept of compound conditions. As their name suggests, compound conditions are higher level conditions that have multiple parts to them. Let's develop our understanding on compound conditions using the examples below:
```{r}
x <- 7
x > 5 && x < 10
```

The above compound condition uses the && (double-ampersand) symbol to combine the conditions x > 5 and x < 10 together. We would read the && as "and". That is to say, the compound condition is asking, "Is x greater than 5 and is x less than 10?" The variable x must satisfy both of these conditions for the compound condition to evaluate to TRUE. In this case, x satisfies both of the conditions, so this should evaluate to TRUE.
```{r}
y <- 7
y < 5 || y > 10
```

Here, the compound condition is using the || (double pipe, not to be confused with %>%). The || character is read as "or", so the compound condition overall is asking, "Is y either less than 5 or greater than 10?". Unlike && where all the conditions need to be met for the compound condition to be TRUE, || only asks that at least one of them be TRUE. Compound conditions can be used in if statements just like regular conditions since they ultimately evaluate to either TRUE or FALSE.

Before we leave you to the practice problem, we must note an important caveat to using if statements. In general, && and || make conditions more specific, which means they require more detail to satisfy. R reads if statements from top-to-bottom and will stop at the first condition that is satisfied. Even if another condition might be satisfied below, R will use the first code block where the condition is TRUE. Because of this, it is best practice to put your more specific conditions higher in your if statements so that they are not accidentally missed.


PRACTICE

We are given the wpm variable again, but instead of classifying with 3 levels this time, we want to categorize typing rates as either "Average" and "Not Average". Using wpm, create a new variable classification that meets the following conditions:
If wpm is between than 68 and 82, assign "Average" to classification.
Otherwise, assign "Not Average" to classification
```{r}
wpm <- 70
classification <- if (wpm >= 68 && wpm <= 82) {
  classification <- "Average"
} else {
  classification <- "Not Average"
}
    
# output:
# wpm
# numeric(double)
# [1] 70

# classification
# character(character)
# [1] "Average"
```

Control Flow in R
7 of 10 · A Technical Note on Multiple Conditions
Learn
In the last screen, we learned how to incorporate multiple conditions into an if statement using && and ||. Since we also know about if_else() function, it's tempting to think that we can use && and || to use multiple conditions in the if_else() function. Unfortunately, this isn't the case. We'll demonstrate in a code example below:
```{r}
a <- 1:3
b <- 4:6

c <- if_else(a > 2  && b > 5, TRUE, FALSE)
```
Looking at the above code, you might expect the variable c to contain multiple values that correspond to the multiple comparison a > 2 && b > 5. On inspection, we see that this is not the case:
```{r}
# output:
# c

# [1] FALSE
```

c only contains one value! Why is this? The reason behind this is actually the behavior of the && and || operators themselves. To summarize why only one value appears in c, it boils down to the fact that && and || are only expecting single values to be used in the multiple comparison. In this case, the multiple comparison a > 2 && b > 5 is only using the first values from the vectors a and b, which are 1 and 4. The other values in a and b are not used at all.

The if_else() function is designed to be used with multiple values, like with a vector or a column in a tibble. Using it with && or || will produce unexpected answers because they are designed to only be used with single values. Thankfully, we do not need to change the code much in order to fix it. Instead of the double && and ||, we only need to use & and |.

```{r}
# Incorrect usage
c <- if_else(a > 2 && b > 5, TRUE, FALSE)

# Correct usage
d <- if_else(a > 2 & b > 5, TRUE, FALSE)

d
# [1] FALSE FALSE  TRUE
```

The vector d uses & instead of && and produces the output we originally expected. The same logic would also apply to | vs ||. So, if you plan to use multiple conditions in an if_else() function, you must use & or | to do so. The explanation for this is out of scope for this lesson, but we will come back to it later.



Control Flow in R
8 of 10 · The case_when() Function
Learn
On the last screen, we learned that we could use the else if keyword to incorporate more than two branches into an if statement. On this screen, we will learn about a new function that will simplify how we handle 2+ branches in an if statement.

We know about the if_else() function, but it works best with simpler conditions that evaluate to TRUE or FALSE. We could potentially nest if_else() functions in other functions, but this could make for hard-to-read code. There is a more elegant solution in the case_when() function.

You can think of the case_when() function as an extension of the if_else() function, which gives room for more branches. We'll demonstrate a use case below with the recent_grads data:
```{r}
new_recent_grads <- recent_grads %>%
  mutate(
    size_classification = case_when(
      Total < 2000 ~ "Small",
      Total > 20000 ~ "Large",
      TRUE ~ "Medium"
    )
  )
```


Within the case_when() function, we have a series of conditions and assignments. The first example is Total < 2000 ~ "Small". The condition Total < 2000 is separated from the assignment "Small" by the character ~ (pronounced "til-deh"). You can think of each of these lines as shortened if branches. The last line, TRUE ~ "Medium", acts as a catch-all in case the Total amount does not fall into either of the conditions above. Another way of interpreting the TRUE ~ "Medium" line is that it is a safety net: if the Total satisfies neither the Total < 2000 or the Total > 20000 condition, then it will be "caught" by the TRUE ~ "Medium" line.

The combination of if_else() and case_when() will help cover most situations where you will need to use the if statement on your data. After finishing this exercise, we'll finish off our overview of if statements.

PRACTICE
Use the case_when() function to create a new column in the recent_grads dataset called unemployment_level. This new column should have the following:
- If Unemployment_rate is less than 5%, unemployment_level should be "Low"
- Between 5% and less than 10%: "Moderate"
- Greater than or equal to 10%: "High"
- Assign your tibble with the new column to the variable new_recent_grads.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())
new_recent_grads <- recent_grads %>% 
  mutate(
    unemployment_level = case_when(
      Unemployment_rate < 0.05 ~ "Low",
      Unemployment_rate >= 0.05 & Unemployment_rate < 0.1 ~ "Moderate",
      Unemployment_rate >= 0.1 ~ "High"
    )
  )
```


Control Flow in R
9 of 10 · Other Useful Comparison Operators
Learn
You've learned about the if statement, if_else() and case_when() functions that enable you to use control flow to do some data cleaning. Before we move onto another type of control flow, we will wrap up if statements by covering some other useful comparison operators.

Currently, we know how to do comparisons on equality and how to determine whether or not one value is greater or smaller than another (==, !=, >, >=, <, and <=). One task that these comparison operators have trouble with is identifying membership in a group. That is to say, given a value, is it present in a collection of values like a vector?

Say that we are performing an analysis on the recent_grads data that involves engineering majors, but only on a particular subset of them. It will be important for us to filter the dataset to just these majors, so we could do something like the following:
```{r}
recent_grads %>% 
  filter(
    Major == "AEROSPACE ENGINEERING" | Major == "BIOMEDICAL ENGINEERING" | Major == "CHEMICAL ENGINEERING"
  )
```

The above compound condition let's us grab these three majors, but there are plenty more majors that we need for the analysis. As we add more, the compound condition will become longer and longer. There is a shorthand way to do this through a membership test. The below code performs the same operation as the one above.

```{r}
recent_grads %>% 
  filter(
    Major %in% c("AEROSPACE ENGINEERING", "BIOMEDICAL ENGINEERING", "CHEMICAL ENGINEERING")
  )
```

Here, we collect all of the three engineering majors and put them into a vector. Then, we use the %in% comparison operator to see if the Major column contains any of these values. If it is in the vector of engineering majors, then this will evaluate to TRUE. Using %in% also makes it much more apparent what the code is doing. Instead of having long streaks of ||, the %in% operator makes it immediately clear that we are testing for membership in a vector. It's important to note that the entire expression Major %in% c("AEROSPACE ENGINEERING", "BIOMEDICAL ENGINEERING", "CHEMICAL ENGINEERING") is a comparison operator.

For the sake of teaching, let's say that we actually wanted to exclude these majors from the analysis. We could reverse the filtering by inverting the comparison operator. Inverting a logical means to change it to its opposite. TRUE inverts to FALSE and vice versa. We can invert the %in% operator to exclude these majors like below:
```{r}
recent_grads %>% 
  filter(
    !(Major %in% c("AEROSPACE ENGINEERING", "BIOMEDICAL ENGINEERING", "CHEMICAL ENGINEERING"))
  )
```

Here, we've wrapped the entire %in% operation in parentheses and prefixed with an exclamation mark ! (pronounced not in programming) at the beginning. By prefixing the comparison statement with a !, the resulting boolean is inverted. Now, any rows that have these three majors will evaluate to FALSE and will be filtered out. You can prefix any comparison operator with ! if you want to invert it.

The %in% operator and logical inversion will help you be more flexible and succinct in your data cleaning and analysis. Take some time to practice using them on the recent_grads data before moving on.


PRACTICE
We want to conduct an analysis on all of the majors with "Arts" in its name. In the context of the data, these are rows where Major_category is either "Arts" or "Humanities & Liberal Arts". Filter the recent_grads data and assign this new tibble to the variable arts_grads.
We want to conduct an analysis on all of the majors that are not "Engineering" or "Physical Sciences". Assign this new tibble to the variable non_engineering_science_grads.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())

# no 1
arts_grads <- recent_grads %>% 
  filter(
    Major_category %in% c("Arts", "Humanities & Liberal Arts")
  )

# alternative code:
arts_grads <- recent_grads %>% 
  filter(
    Major_category == "Arts" | Major_category == "Humanities & Liberal Arts"
  )

# alternative code:
arts_grads <- recent_grads %>% 
  filter(
    Major_category %in% c("Arts") | Major_category %in% c("Humanities & Liberal Arts")
  )

# no 2
non_engineering_science_grads <- recent_grads %>% 
  filter(
    !(Major_category %in% c("Engineering", "Physical Sciences"))
  )
```

Control Flow in R
10 of 10 · Next Steps


Iterations in R
1 of 9 · Introduction
Learn
In the last lesson, we learned about control flow. Control flow gives us the ability to tell R what specific code it should run given a condition. What's special about control flow is that it actually changes how R reads through your code. When we are not using control flow, R reads your code much like a to-do list. R reads the first line, performs the code there, moves to the second line, and repeats until it's read through all of the code.

You might recall that control flow creates a branching path in your code. So, as soon as R encounters an if statement in your code, it looks at the condition and then decides which branch, or line of code it should jump to, before continuing to read down the code.

In this lesson, we'll discuss another way that we can change how R reads through your code, like instances where you need to repeat the same code multiple times. For example, we saw this with the if_else() function that repeated the same comparison operator on each row of the recent_grads data set. We're going to explore this idea more while going through this lesson. This repetition of code is called iteration, and it is a key and fundamental concept to grasp and master in programming. After you get through the exercises, you will have a solid understanding of how to use iteration in your own programming.


Iterations in R
2 of 9 · Motivation for Learning Iteration
Learn
Learning iteration is important because using it correctly can save us time and mindless effort. To demonstrate this, we'll consider a real-life example. Imagine that you are hired as an analyst for a company that sells programming textbooks, and you are now responsible for considering a range of prices to set for a new textbook. To demonstrate your analytical skills, you'll aim to choose the one that will create the most profit for your new company. Let's say the range of prices are as follows:
```{r}
prices <- c(10, 20, 30, 40, 50)

```

The marketing team tells you that if the price is too low, the company does not reap enough profit from each book, and if it's too high, then not enough people will buy the books. They give you a formula that descibes how much profit you'll get based on the price:



With this convenient equation, we can calculate the profit for each price. However, we only have the prices, so how should we calculate the profits from each of them?
One way is to just calculate everything by hand:
```{r}
profits <- c(
  -1 * 10^2 + 60 * 10,
  -1 * 20^2 + 60 * 20,
  -1 * 30^2 + 60 * 30,
  -1 * 40^2 + 60 * 40,
  -1 * 50^2 + 60 * 50)

profits
# [1] 500 800 900 800 500
```


That certainly does the job, but notice that we've essentially written out the same formula five times, only changing a small portion of it each time to represent a different price. In this case, we only have five prices, but what if we had 20? 100? Writing out such a long list of numbers that essentially perform the same operation would take a lot of effort, just to do one type of calculation. This is NOT efficient.

Iteration comes in handy here. Instead of having to write the same equation five times, we could write it just once using iteration. All of the prices would go through this calculation, and we would store the result somewhere else.
```{r}
# Starting with the first price:
    # Calculate the profit based on the price
    # Store this first profit in another vector
    # Now that the calculation on the first price is done, move to the second one
    # Repeat until all of the profits have been calculated
```

In essence, iteration allows us to repeat code many times without having to type it out again and again. This allows us to write less code (which means less possibility for mistakes) and it can express our intent better. In R, there are two types of iteration that we will cover: The for and while loops.



Iterations in R
3 of 9 · The for Loop

Learn
Now that you understand why iteration is useful, it's time to see how to use it in R. Iteration in R means repeating code again using the elements of a vector. There are two ways that R lets us use iteration: a for loop and a while loop. On this screen, we'll learn how to use a for loop.

On the last screen, we started an example problem with a vector of prices, for which we want to calculate a vector of profits. We know how to calculate profit given the price, but our problem is that we want to simplify our code so that we don't have to repeat ourselves too much. We can use a for loop to solve this problem. We'll show an example below, and then we'll dissect it:

```{r}
prices <- c(10, 20, 30, 40, 50)
profits <- c()

for (price in prices) {
  calc <- -1 * price^2 + 60 * price
  profits <- c(profits, calc)
}

profits
# --- output --- #
# [1] 500 800 900 800 500

```

The code above follows a specific structure:

1. The first things we see are the prices vector and a new profits vector.
The prices vector is what we originally had, but now we have a profits vector that has no elements in it. This empty vector will act as a storage for all of the profit calculations.
2. Afterwards, we see the for keyword being used followed by an expression in the parentheses.
The price in prices expression tells R that we want to iterate over all of the elements in the prices vector.
The price variable is special because it represents a single element in the prices vector, what we call a placeholder variable.
3. When the for loop first starts, price is the first element in prices, which is 10.
As we've mentioned, there is a code chunk denoted by the curly brackets {} that follows the for keyword. This code chunk is what will be repeated for every price that's in the prices vector.
Within the code chunk itself, we have a calc variable that actually uses the profit calculation, based on the current price placeholder.
After the calculation is done, it is appended, or added, to the profits vector.
4. After all of the calculation in the code chunk is done when price = 10, the loop will go back to the top and price will become the second element in prices: 20. This process repeats until all of the elements in prices have been exhausted.


The end result is exactly what we got from the last screen, without having to type out the calculation one by one. Instead of having to repeat ourselves, we could use the for loop to write the calculation once and just change out what price is being used.


To make our own for loop, we would need the following:
1. A vector that we want to iterate over (e.g. prices). This can also be called an iterable.
2. The for keyword and a placeholder variable to represent a single value in the iterable (e.g. price).
Note that we can actually name the placeholder variable anything we want. It could be p or pr, but it is often best practice to give it a name that makes it immediately clear what it is supposed to represent. Whatever you choose as the placeholder variable, it should be consistent within the following code chunk.
3. A code chunk that we want repeated for each element in the iterable (e.g. the profit calculation and appending to profits)

This procedure can also be applied when iterating through columns of a tibble using the following method:
```{r}
# create a sample tibble
library(tibble)
df <- tibble(a = 1:5, b = letters[1:5], c = c(TRUE, FALSE, FALSE, TRUE, TRUE))

# iterate through columns using a for loop
for (col_name in names(df)) {
  col_data <- df[[col_name]]
  # do something with the column data
  print(col_data)
}

# output:
# [1] 1 2 3 4 5
# [1] "a" "b" "c" "d" "e"
# [1]  TRUE FALSE FALSE  TRUE  TRUE
```

PRACTICE:
You are given a vector of measurements that are in terms of millimeters (mm). For this exercise, we actually want to convert all of these measurements in terms of meters (m). For reference, 1 meters is the same as 1000 millimeters.

1. Using a for loop, create and append to a new vector called meter_measurements that contains the values converted to meters.
```{r}
millimeter_measurements <- c(10000, 54900, 94312, 49185, 2100)
meter_measurements <- c()

for (milimeter in millimeter_measurements) {
    calc <- milimeter / 1000
    meter_measurements <- c(meter_measurements, calc)
}

meter_measurements

# --- output --- #
# [1] 10.000 54.900 94.312 49.185  2.100
```



Iterations in R
4 of 9 · Using Indexes: Another Way To Write for Loops
Learn
On the last screen, we learned how to make our own for loop. For the most part, writing for loops in this way satisfies most of the situations that you'll need. There is another way of writing for loops that work exactly as in the last screen, but differs in how we get the elements of the vectors.

On the last screen, the for loop was written like below:
```{r}
prices <- c(10, 20, 30, 40, 50)
profits <- c()

for (price in prices) {
  calc <- -1 * price^2 + 60 * price
  profits <- c(profits, calc)
}
```

In the above example, the placeholder variable price uses values directly from the prices vector. The alternative way to use for loops is to take advantge of indexing. Recall that we can access the elements of a vector directly using indexes, which represent their place in the vector. Instead of iterating through the actual elements of the iterable, we can iterate through the positions (indices) instead. We can rewrite the above for loop below:
```{r}
prices <- c(10, 20, 30, 40, 50) # create a vector of prices
profits <- integer(length(prices)) # initialize a vector of profits with same number of elements as proces, filled with zeros

indices <- 1:length(prices) # generate a sequence of indices from 1 to the number of elements in the prices vector

# start a for loop, iterating over each index in the indices vector
for (i in indices) {
  calc <- -1 * prices[i]^2 + 60 * prices[i] # calculate the profit for the current price at index i
  profits[i] <- calc #Add the calculated profit to the profits vector using the c() function.
  
}

profits

# --- output --- #
# [1] 500 800 900 800 500
```

We've added comments to guide you through each line of code step by step. Both for loops perform exactly the same function, but the index-based presentation uses the position numbers to access each price. With prices[1] getting the first price, prices[2] gets the second price, and so on.

When we iterate over indices, we need to construct a vector of zeroes instead of an empty vector. If we start with an empty vector, then trying to access profits through an index wouldn't work. To create this vector of zeroes, we use the integer() function and length() function. Using these two functions together creates a vector of zeroes that is the same length as the prices vector. For every index, we are reassigning the zero with the result of the calculation calc. This is what you see with profits[i] <- calc.

In general, looping through indices makes your code less readable compared to looping through elements. "Less readable" really means that it's less apparent what your code is doing. The trade-off is that you have more flexibility to incorporate more data (ie more vectors) into the for loop. In this case, we're only dealing with prices, so it's not as useful here but it's important that you are aware of this other style of writing for loops.

PRACTICE
We have provided the same measurements as on the last screen. Rewrite your for loop to use indices instead of the actual elements of prices.

Using a for loop, create and append to a new vector called meter_measurements that contains the converted millimeter values.
For answer checking purposes, make sure to use i as your placeholder variable.
```{r}
millimeter_measurements <- c(10000, 54900, 94312, 49185, 2100)
meter_measurements <- integer(length(millimeter_measurements))

indices <- 1:length(millimeter_measurements)

for (i in indices) {
  calc <- millimeter_measurements[i] / 1000
  meter_measurements[i] <- calc
}

meter_measurements
# --- output --- #
# [1] 10.000 54.900 94.312 49.185  2.100
```



Iterations in R
5 of 9 · Understanding The while Loop
Learn

We've covered the for loop in great detail in this lesson because it's the loop that you'll deal with the most practically. The second type of loop is still useful to know, but it's better suited to analytical situations that are outside the scope of this course. This second loop type is called a while loop.

To distinguish between these two loops, it's useful to think of a for loop as dealing with a chore list. The idea being that you have a set amount of chores to finish, and once you do all of your chores, you're done. The key here is that there is a set amount of items that we need to loop through in a for loop.

On the other hand, a while loop is like trying to reach a milestone, like raising a target amount of money for a charity event. For charity events, you typically perform and do things to raise money for your cause, like running laps or giving services to people. You do these tasks to raise money until you reach your target goal, and it's not clear from the beginning how many tasks you need to do to reach the goal. That's the key idea behind a while loop: repeat some actions (read: a code chunk) until a condition or goal is met.






Iterations in R
6 of 9 · Understanding while Loops with Examples
Learn
Unlike their counterparts, while loops require more preparation to use. If this preparation is not done, then we could run into serious problems with our loop. We provide a small example of a while loop that counts from 1 to 5 below:

```{r}
# Initialize the counter to start at 1
counter <- 1

# The loop should run as long as the counter is less than or equal to 5
while (counter <= 5) {
  # Print the current value of the counter
  print(counter)

  # Increment the counter by 1
  counter <- counter + 1
}
```
In the example above, we start with a counter variable set to 1. The while loop then begins to check if counter is less than or equal to 5. If true, it prints the counter's current value. Then, it adds 1 to the counter. The loop runs until counter is greater than 5, then stops.

Let's look at another example with a bit of logical reasoning:
```{r}
nums <- 1:10    # Vector of numbers from 1 to 10
is_condition_met <- FALSE   # Condition flag, starts as FALSE
i <- 1   # Index to access elements in nums

# Loop execution
while (!is_condition_met) {

  current_num <- nums[i]    # Grab a number using the index
  is_condition_met <- current_num > 7 # Update the condition with a logical test
  i = i + 1 # Increase the index for the next iteration
}

# The code creates a vector of numbers from 1 to 10, initializes a condition flag as FALSE, and sets an index to 1. It then enters a while loop, which continues as long as the condition flag is not TRUE.

# Inside the loop, the code grabs a number from the vector using the index, updates the condition flag based on whether the current number is greater than 7, and increments the index for the next iteration.

# Once the condition flag is TRUE (i.e., when the current number is greater than 7), the loop stops executing. In this case, the loop will iterate 7 times, and the final value of the index (i) will be 8.
```

Here’s what’s happening in the code above and keep in mind that it's best to break down a while loop into two parts: 1) the set up and 2) the loop itself.

The set up: 1. nums <- 1:10 creates a list of numbers from 1 to 10. Think of it like a line of people numbered 1 through 10.

is_condition_met <- FALSE sets up a criteria that will help us decide when to stop the loop. For now, it's like we have a sign that says "No, we haven't reached our number yet."

i <- 1 sets up a counter starting at 1. This will help us keep track of which number we're looking at from 1 to 10.

Now we get to the while loop itself:

while (!is_condition_met) { ... } means "keep looping inside the brackets as long as our condition is false.

current_num <- nums[i] takes the number at the position we're currently looking at, which starts at position 1.

is_condition_met <- current_num > 7 checks if the number we're currently looking at is greater than 7. If it is, the loop terminates because, we've reached our number!, else, it continues.

i = i + 1 adds 1 to our counter, so next time the loop runs, we'll be looking at the next number in line.



It's worth mentioning what happens when we don't change the is_condition_met variable. If this variable never changes, then the condition that runs the loop never stops. Your code will look as if it's "frozen" up, but it's actually just running your code infinitely!

Don't worry if this whole process seems daunting. while loops take a bit to understand, but they can be powerful tools once mastered. There are a lot of different variables to juggle, but the key to understanding the while loop is to know how these variables change everytime the loop runs. In the next screen, you'll have your turn to create your own while loop, but for now, explore the code we've provided to you.

PRACTICE:
```{r}
nums <- 1:10
is_condition_met <- FALSE
i <- 1

# Loop execution
while (!is_condition_met) {

  print(paste("The loop has run", i, "time(s)"))

  current_num <- nums[i] # Grab a number using the index

  print(paste("current_num is currently:", current_num))  
    
  is_condition_met <- current_num > 7 # Recheck the condition
    
  print(paste("is_condition_met is currently:", is_condition_met))
    
  i = i + 1 # Increase the index

  print(paste("The index i has been set to:", i))    
    
}
```



Iterations in R
7 of 9 · Your Own while Loop
Learn
We've covered the while loop in great detail over the past two screens. On this screen, you'll finally have a go at constructing your own loop. For your convenience, we've also provided the while loop we covered before to let you review its structure.
```{r}
# Loop set up
nums <- 1:10
is_condition_met <- FALSE
i <- 1

# Loop execution
while (!is_condition_met) {

  current_num <- nums[i] # Grab a number using the index
  is_condition_met <- current_num > 7 # Recheck the condition
  i = i + 1 # Increase the index
}
```

Before we tackle the exercise, it's worth mentioning the importance of while loops. For the curious, while loops play a major roles in heavy analytical tasks like simulation and optimization. Optimization is the process of finding a set of parameters that either maximize or minimize some goal. Think back to the price-profit example from the for loop example; that was an example of an optimization problem. We were given a vector of prices to use, but there are times that we won't know what prices to try. In this case, it's better to use a while loop to experiment with many, many prices until we see a clear "peak" in the profits.

In typical data analysis tasks like data cleaning or statistical computations, which you’ll frequently encounter in the Data Analyst track and potentially in your career, while loops may not be as applicable. It's beneficial, though, to be aware of the different tools available to you as a programmer.




PRACTICE
Your exercise is to write a while loop that tells you the price you should purchase the stock for.
Imagine that you decide to buy a stock as soon as you see that the price has dipped below $70.
What price will you end up purchasing the stock for? Assign this price to the variable buy_price.
```{r}
prices <- c(138.19, 82.72, 118.97, 77.55, 62.28, 89.71, 97.36, 91.98, 113.45, 73.93)
is_below_70 <- FALSE
i <- 1

while (!is_below_70) {
  current_price <- prices[i] #grab a number using index
  is_below_70 <- current_price < 70
  i = i + 1
}

buy_price <- current_price
buy_price
# output: 62.28
```

This code creates a while loop that goes through the prices vector until it finds a price below 70.


breakdown of the code:

prices is a vector of prices.
is_below_70 is a boolean variable that is initially set to FALSE.
i is a counter that starts at 1.
The while loop checks if is_below_70 is FALSE. If it is, the loop executes the following code:

current_price is assigned the value of the price at index i in the prices vector.
is_below_70 is updated to TRUE if current_price is less than 70.
i is incremented by 1.
Once the loop finds a price below 70, is_below_70 is set to TRUE, and the loop terminates. The buy_price variable is then assigned the value of the current_price at the last iteration of the loop.

In this case, the loop will iterate through the prices vector until it finds a price below 70, and then it will store that price in the buy_price variable. If all the prices in the prices vector are above 70, then buy_price will be NULL.




Iterations in R
8 of 9 · Iteration vs Vectorization
Learn
In R, for and while loops allow for iteration, which is a key concept we've explored. As we wrap up this lesson, it is important to understand how iteration fits into your workflow as a programmer. Recall that from the Control Flow lesson, we used the if_else() function to apply an if statement on each value of a whole column to create a new column of TRUE and FALSE. In other words, the if_else() function vectorizes the if statement.

Actually, a for loop can also achieve the same result as the if_else() function. So this raises the question, "If iteration and vectorization can produce the same output, which one should I use?"

The answer is almost always *vectorization*. The reason for this is how vectorization calculates its output compared to iteration. A brief example illuminates this. Let's say that we have a vector of numbers, and all we want to do is divide all of them by 1000. We'll show you how to do this through both iteration and vectorization.
```{r}
nums <- c(1000, 2000, 3000, 4000, 5000)

# Approach 1: Iteration
divided_nums <- c()
for (n in nums) {
  calc <- n / 1000
  divided_nums <- c(divided_nums, calc)
}

# Approach 2: Vectorization
divided_nums <- nums / 1000

```

It's clear that vectorization can produce the same output as iteration in less code! In iteration, we are changing values one at a time. Each time we are in the loop, we are only changing one value of nums. With vectorization, the division is applied to all the values in nums at the same time, which makes it faster than iteration.

You may have noted that we have followed a particular way of teaching you new functions throughout our Intermediate R lessons. We always try to teach you a function that vectorizes some particular operation. The if_else() function vectorizes if statements, the mutate() function vectorizes the creation of new columns, etc. Vectorization is the reason that we use & and | in if_else() functions instead of && or ||. The single-character versions are vectorized versions of their double-character counterparts. Vectorization works well with the tidyverse libraries, and as a rule of thumb, prioritize using vectorized functions for your tasks.

While there are many functions out there that vectorize particular calculations, there are still some tasks that cannot be vectorized. This is where iteration becomes useful. While we should always be looking to vectorize calculations, we can take comfort knowing that we have other available options.


PRACTICE

Instructions
A vector of temperatures temperatures <- c(22.6, -15.6, 67.7, 18.5, 98.8) is available on the code editor screen. These temperatures are in degrees Fahrenheit (℉). We would like to convert each of these temperatures into degrees Celsius (℃). For a given temperature in Fahrenheit (F), we can convert it to Celsius (C) using the formula:

C = (F−32) × 5/9

Using a for loop, convert each of the values in temperatures into Celsius and store it into another vector called celsius_iteration.
In your for loop, name your placeholder variable temp. This is used to check your answer.
Ensure you use the formula exactly as it is shown above and do not use parentheses to wrap the fraction. While this operation would be mathematically equivalent and would appear to produce the same result, sometimes R doesn't think numbers are equal.
Use vectorization, convert each of the values in temperatures into Celsius and store it into a vector called celsius_vectorization.

```{r}
temperatures <- c(22.6, -15.6, 67.7, 18.5, 98.8)

celsius_iteration <- c()
for (n in temperatures) {
    temp <- (n - 32) * 5/9
    celsius_iteration <- c(celsius_iteration, temp)
}

celsius_vectorization <- celsius_iteration
```

Iterations in R
9 of 9 · Next Steps
In this lesson, we learned about iteration and how to implement them in R using the for and while loops. We also found out that for loops are better suited for cases with a defined set of elements where we need to iterate over, and while loops are better for when we need to satisfy a particular condition through our loops. In the next lesson, we'll learn how to make our own custom functions in R.





Functions in R
1 of 8 · Introduction

Learn
Welcome back! In our previous lesson, we covered how to use control structures and various functions with tibbles and the tidyverse libraries. Throughout the course, we learned about functions and just described how to use them in particular contexts. As we continue our learning journey with R, it is time for us to dive deeper into functions in R.

Functions are a fundamental tool in a programmer's toolkit. You can think of functions as recipes in cooking which describes how to take raw ingredients and process them according to a set of steps that ultimately produces a finished meal. In programming, functions have similar behavior to cooking recipes by taking inputs in the form of data (numbers, strings, etc.), processes this data with help of some code, and outputs a modified form of the data that can also be further used in your programming.

We have encountered some functions that behave alike. The if_else() function takes a column of values and pushes all these values through an if-else statement. The read_csv() function takes a string that represents the location of a CSV dataset and outputs a tibble that contains a copy of this data.

Functions are important to programmers because it allows us to reuse code in quick, readable lines. Rather than repeating many steps in a complicated operation, we can wrap it up inside a function and use it wherever we need. For example, take the mean() function from base R that calculates the average value of a given vector — we could manually write out the average calculation:
```{r}
nums <- 1:10
mean_nums <- sum(nums) / length(nums)
mean_nums
```

Nothing stops us from writing out sum(nums) / length(nums) every time we need to calculate an average but this can get tiring and if you were not familiar with how to calculate an average, you might look at the bit of code and not know what it does. Meanwhile, having a code that reads like:
```{r}
nums <- 1:10
mean_nums <- mean(nums)
mean_nums
```
makes it clearer and particularly states what the code is doing. Another benefit of applying functions is to reduce Code Redundancy: reducing the amount of repeated codes we have to write. If you ever find yourself writing the same code over and over again, it might be worth turning it into a function. If you need to change this code, all you need to do is change the function code instead of having to look for all your repeated codes. In this lesson, we'll learn how to create our own functions instead of having to rely purely on R's pre-built functions.



Functions in R
2 of 8 · Components Of A Function
Learn
On the last screen, we made a comparison between a programming function and a recipe.

These three sections are what make up a function: inputs, an internal code chunk, and an output. We'll explore these three different components and use them to demonstrate how functions are actually built in R. Let's make our own version of the mean() function to demonstrate this:
```{r}
example_mean <- function(nums) {
  sum_nums <- sum(nums)
  length_vec <- length(nums)
  
  return(sum_nums / length_vec)
}

```

The above code creates and assigns a function named example_mean. By specifying function, we are telling R that we want to create a function. After the function keyword, we have a nums variable inside the function's parentheses. These parentheses help define the input of our example_mean function — the data that the function will take and transform.

Now that we have the nums input, we need to create code that transforms the nums input into an average. After the function keyword, we have a code chunk surrounded by curly brackets. Within this code chunk, we calculate the two components that are needed to calculate an average. The only time that this code will be run is when the example_mean() function is being used.

Finally, we have the return keyword. Once we have all of the values we need, we need to tell the function what value it should give back to the user. For our function, we want to output the average, so this is what we put inside the return's parentheses.

To recap, all functions have this essential format: Name the inputs, write out code in the code chunk, and return the output. In order to use the function, you would need to refer to it by the variable you assigned it to. For example:
```{r}
example_mean <- function(num) {
  sum_nums <- sum(nums)
  length_vec <- length(nums)
  
  return(sum_nums / length_vec)
}

avg <- example_mean(1:10)
avg
```

PRACTICE

1. Create a function called find_longer_vector() which takes two vectors (inputs) and tells you which one is longer.
If the first vector is longer, the function should return the string "First".
If the second vector is longer, it should return the string "Second".
If they are equal, it should return the string "Equal Length".
2. Using the two given vectors, first_vec and second_vec, apply them to your find_longer_vector() function to see which one was longer. Assign your answer to the variable first_vs_second.
3. Using the two given vectors, first_vec and third_vec, apply them to your find_longer_vector() function to see which one was longer. Assign your answer to the variable first_vs_third.

```{r}
first_vec <- c(1, 5, 4, 2, 3, 7, 6)
second_vec <- c(9, 2, 1, 8, 3, 4, 5, 6, 10, 7, 12, 11)
third_vec <- c(8, 3, 5, 1, 7, 1, 10)

find_longer_vector <- function(vec_one, vec_two) {
  if (length(vec_one) > length(vec_two)) {
    return("First")
  } else if (length(vec_one) > length(vec_two)) {
    return("Second")
  } else {
    return("Equal Length")
  }
}

first_vs_second <- find_longer_vector(first_vec, second_vec)
first_vs_third <- find_longer_vector(first_vec, third_vec)

first_vs_second
first_vs_third
```



Functions in R
3 of 8 · Namespaces For Functions
Learn

On the last screen, we created the example_mean function which calculates the mean of a vector of numbers.
```{r}
example_mean <- function(nums) {
  sum_nums <- sum(nums)
  length_vec <- length(nums)
  
  return(sum_nums / length_vec)
}
```

Within the code chunk of the example_mean() function, we defined two variables sum_nums and length_vec. These two variables are only accessible when the function is used. After the function calculates and returns its value, they become inaccessible. For example, calculating a mean and then trying to access sum_nums will throw you an error:
```{r}
test_mean <- example_mean(1:20)

> sum_nums
Error: object 'sum_nums' not found
```

This leads us to the concept of namespaces. The sum_nums and length_vec variables only exist in the namespace of the example_mean() function. The namespace is essentially the environment that variables and functions live in. Once the example_mean() function is created, it is also stored in the overall namespace. Once the example_mean() function is called, it will have its own namespace as well. The diagram below summarizes this:...

In this diagram, the outer namespace contains the example_mean() function which has been defined. It's only when example_mean() is being used that its own namespace is created. Furthermore, any variable in the outer namespace cannot access variables in the inner namespace. The important takeaway from namespaces is to understand and recognize where your variables are defined. As you make your functions, you may try to reference a variable that only exists inside of a function. You can save yourself some time and frustration by keeping track of which namespace your variables are in.




Functions in R
4 of 8 · Functions with Multiple Inputs
Learn

Initially, we created the example_mean() function which took only one input nums and returned its average. In R, functions can be extremely flexible and are capable of handling more than one input, increasing their overall capabilities. Let's say that we want to make a function that takes two numbers, divides them and returns the remainder, much like the modulo operator %%. We would write this function as follows:

```{r}
remainder <- function(dividend, divisor) {
  whole <- floor(dividend / divisor)
  rem <- dividend - (whole * divisor)
  
  return(rem)
}
```

Our remainder() function takes two inputs, dividend and divisor, both seperated by a comma. Commas are used to seperate multiple inputs inside the parentheses after the function keyword.

It's important to know that order matters when we pass in inputs to a function. For our remainder() function, the first input will be used as dividend, and the second one will be used as divisor. Another way of saying this is that the output of remainder(4,3) will be different from remainder(3,4) because different numbers get assigned to different inputs. Their positions determine how they will be used within the function, making them positional inputs: the position they take when you call the function.

The floor() function is a built-in R function that rounds a number down to the nearest integer that is less than or equal to it. It takes a numeric input and returns a numeric output. For example, floor(3.9) returns 3 because 3 is the largest integer that is less than or equal to 3.9.

In the context of the remainder() function, the floor() function is used to calculate the number of times the divisor can be divided into the dividend without a remainder. This is the whole number part of the division operation, or the quotient rounded down to the nearest integer. For example, if dividend is 10 and divisor is 3, then floor(10 / 3) returns 3, which is the number of times 3 can be divided into 10 without a remainder. This value is stored in the variable whole, which is then used in the next line of the code to calculate the remainder of the division operation.

The third line of the code rem <- dividend - (whole * divisor) is calculating the remainder of the division operation between dividend and divisor.

With this knowledge, you'll make your own multiple input function before moving on.

PRACTICE
Instructions
1. Create a function called is_divisible that takes two numbers and calculates if the first one is divisible by the second one. Divisible means that two numbers can be divided, and there will be no remainder. If the two numbers are divisible, return TRUE. If not, return FALSE.
2. Use your is_divisible() function to check if 5731 is divisible by 11. Assign your answer to the variable div_5731_by_11.

```{r}
is_divisible <- function(dividend, divisor) {
  whole <- floor(dividend / divisor)
  rem <- dividend - (whole * divisor)
  
  if (rem == 0) {
      return(TRUE)
  } else {
      return(FALSE)
  }
}

div_5731_by_11 <- is_divisible(5731, 11)
div_5731_by_11

# output: TRUE
```



Functions in R
5 of 8 · Default Arguments in Functions
Learn

On the last screen, we learned how to use multiple inputs in our functions. On this screen, we'll learn how to differentiate the different types of inputs and their uses. A synonym for input is argument. For the most part, we will refer to the items we give to functions as inputs, but it's important to be aware that inputs can be substituted with arguments or other words.

In order to use a function, it must be supplied with all of the inputs that it expects. The example_mean() function was created with one input, and that's what we gave it. The remainder() function had two, and it will only work if given two inputs. You can think of these as required inputs/arguments.

There is another type of input/argument where we can tell the function to assume a certain value. If the function is created with an input of a particular value, it will use that value unless told otherwise. Let's examine a slight variant of the remainder() function:

```{r}
remainder2 <- function(dividend, divisor = 2) {
  whole <- floor(dividend / divisor)
  rem <- dividend - (whole * divisor)
  
  return(rem)
}

```

The above remainder2() function is similar to the remainder() from the last screen, but with a slight tweak. Instead of requiring the programmer to provide an input for the divisor parameter, remainder2() will assume that divisor = 2 if not otherwise specified. Instead of giving remainder2() two inputs, it can just be given one, which will be supplied to the dividend part.

In remainder2(), divisor = 2 is what we call a keyword argument with a default value of 2. Keyword arguments are useful because we can specify default values for functions. If you wanted to use a different value for the keyword argument, you will actually need to refer to it by its input name. For example, if we wanted to use remainder2() to divide by 3 instead, we would write the following:

```{r}
remainder2(9, divisor = 3)
```

Following this convention, we can write out all of the inputs as keyword arguments. This could be valuable in cases where you're working with other programmers and you want to be as explicit as possible in your code.
```{r}
remainder2(dividend = 9, divisor = 3)
```
On the other end of the spectrum, we may also simply write remainder2(9, 3), but this assumes some more knowledge of the function itself. By outrightly specifying divisor = 3 in the code, it gives more information to others who might be reading your code. Keyword arguments are a useful tool to be aware of when creating and using functions.




Functions in R
6 of 8 · Managing Functions with Variable Arguments
Learn

On the last screen, we learned about both positional and keyword/default arguments. These arguments are important because they are how you give your data a variable name within the namespace of your function. When we use positional and keyword arguments in our functions, we are also implyfing that there is a set number of variables that the function needs to run. For instance, the is_divisible() function we created earlier expects and will take only two arguments: divisor and dividend. Now, what if we don't know the number of arguments we need ahead of time? What do we do in this situation? In other words, what if we need a function to handle a variable number of inputs?

This situation comes up frequently in programming problems that we will discuss more on the next screen. For now, we will use an example to illustrate this. Let's say we have a function that performs a simple calculation of adding two numbers together:
```{r}
add <- function(x, y) {
  return(x + y)
}
```

As you might expect, this function just takes in two arguments x and y and returns the result of their addition. Suppose we want to expand the functionality of this add() function by letting it add up any amount of numbers that we pass to it. In other words, we want the add() function to be more flexible in accepting a variable number of arguments. How would we do this?

R gives us a special construct to represent extra arguments that we add to a function. We call it the three-dot construct. Let's create a new function called new_add() function and build it up:
```{r}
new_add <- function(x, y, ...) {
  return(list(...))
}
```

In its form above, the new_add() function doesn't do any adding. It just returns the three-dot construct in the form of a list. To see why this is useful, let's use our new_add() function in two ways:
```{r}
add <- function(x, y) {
  return(x + y)
}

new_add <- function(x, y, ...) {
  return(list(...))
}

new_add(1, 2, z = 3)
$z
[1] 3

new_add(1, 2, z = 3)
$z
[1] 3
```

In both of the examples above, the numbers 1 and 2 are used for the x and y arguments respectively. What's new here is that we are adding new arguments that are not specified in new_add(). Since they are not specified, R assumes that they will be a part of the three-dot construct. In the first use of new_add(), we see that the z argument is put in a list. We put it in a list because it allows us to see exactly what was in the ... construct. The z name is associated with what we originally assigned it (z = 3). We see the same for the second use: both z and w are a part of the list that we pass ... into. This is what allows us to handle a variable amount of arguments. Anything that cannot be used as a positional or keyword argument will be assumed to be a part of the three-dotconstruct, and we can access all this information as long as we put it in a list. You can imagine if we added a fifth argument tonew_add(). It will also be put in the list the same way aszandw`.

Now let's finish up our new_add() function:

```{r}
new_add <- function(x, y, ...) {
  current_num = x + y

  for (num in list(...)) { 
    current_num = current_num + num
  }

  return(current_num)
}

new_add(1, 2, z = 3)
# output: 6
new_add(1, 2, z = 3, w = 4)
# output: 10
```

Above, the new_add() function uses a for loop to iterate through all of the numbers that are contained in list(...). Since we don't know how many numbers will be in ... ahead of time, we just iterate through all of the elements that would be in it once the function is run. Don't worry if you don't understand this right away, variable arguments are less intuitive to use than positional or keyword arguments, but they can add another degree of flexibility in your code.

Now that you're familiar with the three-dots construct, try creating a function that utilizes it. This could be a function that takes an arbitrary number of numeric inputs and performs an operation like addition, multiplication, or finding the maximum. On the next screen, we'll learn a more realistic, everyday use case for the three-dots construct in functions.


PRACTICE
1. Create a function called subtract_all() that takes a starting number as the first argument and then a variable amount of numbers. The subtract_all() function should subtract all the numbers that are given to it from the starting number and then return the result of all of the subtraction.
2. Using your subtract_all() function, start with the number 10 and subtract the numbers, 1, 2, and 3, from it. Assign the result to the variable first_subtraction.
3. Using your subtract_all() function, start with the number 100 and subtract the numbers, 71 and 22, from it. Assign the result to the variable second_subtraction.
```{r}
subtract_all <- function(start, ...) {
  current_num <- start
  
  for (num in list(...)) {
    current_num <- current_num - num
  }
  
  return(current_num)
}

first_subtraction <- subtract_all(10, 1, 2, 3)
second_subtraction <- subtract_all(100, 71, 22)

first_subtraction
second_subtraction
```



Functions in R
7 of 8 · Nested Functions
Learn

As we wrap up this lesson on functions, we'll discuss one last use case for the three-dots construct, which lets us handle a variable number of arguments. This use case strikes at the heart of why functions are useful to us, allowing us to take a more complicated operation/calculation and perform it in one line of code.

Functions make themselves even more helpful in problems where there might be multiple types of calculations to perform. Let's say that we have a process that can be contained in three functions:
```{r}
clean_data <- function(data) {
  # Data cleaning code is contained in here
}

analyze_data <- function(data, analysis_parameters) {
  # This function takes clean data and does analysis on it
}

create_report <- function(analyzed_data, report_parameters) {
  # This function creates a nicely formatted report from the analysis
}
```


The actual code is not important, but this represents a common situation that you might find yourself in. Starting with raw data, you create different functions to handle some of the basic tasks in data analysis: cleaning, then analyzing, and reporting the results.

Now, you might be tempted to stop here and just run each of the functions one after the other, but there is an alternative to this. Instead of running these three functions every time you need to, you could also write another function that contains all of them and just returns the final report. In other words, you can simplify your entire workflow into one line by writing a function that contains or nests, the other functions in it.
```{r}
# A workflow function that nests the entire process
perform_workflow <- function(data, ...) { 

  # Store all the extra parameters in a list to access later
  varargs <- list(...)

  final_report = data %>%
    clean_data() %>%
    analyze_data(analysis_parameters = varargs$analysis_parameters) %>%
    create_report(report_parameters = varargs$report_parameters)

  return(final_report)
}

# call the perform_workflow function with the necessary data
data <- read_csv("some/path/to/data.csv")
example <- perform_workflow(data, 
                            analysis_parameters = "setting1", 
                            report_parameters = "setting2")

```


In the above example, we create a new function perform_workflow() that nests the three functions for our data analysis workflow. The analyze_data() and create_report() functions take parameters that need to be passed into it, so we use the three-dots construct to hold these when we need them. The three-dots construct gives us a lot of flexibility when we make our workflow function. This particular process only takes 3 functions, but your own workflows can contain many more functions, each with their own argument needs. The ... allows us to keep our perform_workflow() function short, while allowing us to add as many functions and extra arguments that we might need.

We could specify an analysis_parameters and report_parameters in the arguments list of perform_workflow(), but this could get long fast, especially if we're working with more functions with their own parameters.

Functions in R
8 of 8 · Next Steps
In this lesson, we learned how to create our own functions which simplifies repetitive tasks like the remainder() function. We explored how functions can handle multiple inputs, default arguments, and variable numbers of arguments. We introduced the concept of nested functions, particularly using the three-dot construct.

Like control flow, functions are an essential programming skill to learn. As you progress through the R path, you will be introduced to more and more functions.

In the next lesson, we'll dive into string handling in R with more sophisticated techniques. This will include manipulation, formatting, and analysis of string data. String handling is an essential skill, especially in data processing and analysis, where text data is a common occurrence.





String Manipulation in R: Fundamentals
1 of 10 · Introduction
Learn

After learning the fundamental concepts of R: data structures, control flow, functions, iterations, it's important that we understand how to manipulate different types of data while applying what we now already know.

If we recall from our introduction to R, there are basic data types in R: numbers (integers and doubles), logicals (TRUE and FALSE), factors, and strings. So far, we mainly worked with numerical data and logicals, but we have not really explored strings.

In this lesson, we'll fill this blank and go through a detailed review of what strings are and what we can do with them. Strings are how R represents text, whether we are talking about tweets, electronic medical records or Amazon reviews, text data is everywhere. Compared to numerical data, text data can be harder to clean and manipulate since it involves dealing with lots of words. We also can't typically do numerical calculation directly with text; we need to perform some cleaning steps beforehand.

Typical work with strings usually has to do with finding specific words or phrases in a larger paragraph, or counting the number of times it appears in a passage. By the end of this lesson, we'll know how to use many of the functions that help us with string manipulation, which further opens up our capabilities as a programmer.



String Manipulation in R: Fundamentals
2 of 10 · Indexing Strings
Learn

Before we learn about the various string manipulation functions, we will review an important aspect of strings. In R, a string is also known as a character vector. Throughout this lesson, we'll use these two phrases interchangeably. The word "vector" here is important because it hints at how strings are structured in R. Vectors are ordered lists. So, there's a method to the "first item" of a vector, the "last item" and so on.

In R, we can locate or index, particular elements of a vector using numbers. The first item in a vector is indexed by the number 1. For example, we can get the first item of a vector of numbers like below:
```{r}
nums <- 1:5
nums[1]
# output: 1
```

We can think of any string as a vector of letters, numbers and symbols. We denote strings by surrounding them with single quotes as in 'string' or with double quotes, as in "string". One rule to follow is to never mix the quotes like "string'. You will get an error message. However, same way we index a numerical vector with numbers, we can also index character vectors in the same way, but with caution. Let's see the example below:
```{r}
words <- "Dataquest is awesome"
words[3]
# output: NA
```

You may have thought that R would interpret it as three words but surprisingly, this results in NA because R interprets the entire sentence, "Dataquest is awesome", as a one-element vector containing that whole string. Here's the proof:
```{r}
words <- "Dataquest is awesome"
words[1]
# output: [1] "Dataquest is awesome"
```
In order to get a substring of the string, we need to use the str_sub() function from the stringr library. The stringr library is a component of the tidyverse libraries, dedicated to handling strings. To get the first word from the string "Dataquest is awesome", we need to supply 3 arguments to the str_sub() function.
```{r}
library(stringr)
str_sub(words, 1, 9)
# output: [1] "Dataquest"
```
The first input is the string we want to get a substring from. The second input is where we want to start indexing the string, while the third input is where we want to end the indexing. Dataquest is 9 letters long, so our end index is 9.

Now, let's introduce another concept: negative indexing. Negative indexing allows us to count from the end of a string, making it quite handy. For example, to get the last word awesome from the sentence "Dataquest is awesome", we can use:
```{r}
str_sub(words, -7, -1)
# output: [1] "awesome"
```

Here, -7 represents the 7th character from the end, and -1 represents the last character. This way, we can easily access the desired substring even when we don't know the exact character count. Negative indexing is a powerful tool for working with strings in R. Let's practice.

PRACTICE
1. Get the first 4 letters of the word "Dataquest" and assign it to the variable first_four_letters.
2. Get the last 2 letters of the word "Dataquest" and assign it to the variable last_two_letters. You can use negative indexing if you wish.
```{r}
library(tidyverse)
word <- "Dataquest"
first_four_letters <- str_sub(word, 1, 4)
last_two_letters <- str_sub(word, -2)

```




String Manipulation in R: Fundamentals
3 of 10 · Handling Word Casing
Learn

One particularly common string manipulation task in data analysis is changing the column names of a dataset. As with other lessons, we'll use the recent_grads dataset to practice our skills. Below are the original column names of recent_grads:
```{r}
colnames(recent_grads)

# [1] "Rank" "Major_code" "Major" "Total" "Men"                 
# [6] "Women" "Major_category" "Sample_size" "Employed" "Full_time"           
# [11] "Part_time" "Full_time_year_round" "Unemployed" "Unemployment_rate" "Median"       
# [16] "College_jobs" "Non_college_jobs" "Low_wage_jobs"

```
Notice that each of these column names are strings and start with a capital letter. However, it's common practice to standardize the column names by turning everything into lowercase. Having each letter in lower case makes them easier to type and worryless about letter casings. It's a small detail, but it's good practice to incorporate into our analysis.

Instead of manually replacing the first capital letter for each of the column names, we can turn to another function from stringr called str_to_lower(). This function just takes a character vector, and converts all of the letters to lowercase:
```{r}
str_to_lower(colnames(recent_grads))

# [1] "rank" "major_code" "major" "total" "men"                 
# [6] "women" "major_category" "sample_size" "employed" "full_time"           
# [11] "part_time" "full_time_year_round" "unemployed" "unemployment_rate" "median"       
# [16] "college_jobs" "non_college_jobs" "low_wage_jobs"

```

There's a reverse function to str_to_lower() that converts everything to uppercase: the str_to_upper() function. There are less situations where we might want to convert everything into uppercase, but knowing that the function exists can be helpful.

PRACTICE

1. Convert the column names of the recent_grads dataset to lowercase and assign them to the vector lower_case_colnames.
2. Using the function str_to_lower() doesn't directly change the column names of the tibble, we actually need to reassign colnames(recent_grads) in order to do this. Using lower_case_colnames, reassign the column names of recent_grads to be all lowercase.
```{r}
library(tidyverse)
# Supply col_types = cols() to suppress column specification output
recent_grads <- read_csv("recent_grads.csv", col_types = cols())
lower_case_colnames <- str_to_lower(colnames(recent_grads))
colnames(recent_grads) <- lower_case_colnames

```



4 of 10 · String Trimming & Padding
Learn
Another common string manipulation task is cleaning up strings by removing unnecessary whitespace. This process, known as trimming, is common in tasks like web scraping where the string data comes from sources like HTML and CSS. For example, take the following string:

```{r}
padded_string <- "     Dataquest      "

```

padded_string has extra spaces that come before and after the word "Dataquest". In order to trim the leading and trailing whitespace, you can use the handy str_trim() function from stringr. The str_trim() function by default takes any character vector and removes all of the whitespace from both sides of the string.

```{r}
library(tidyverse)
str_trim(padded_string, side = "both")
"Dataquest"

```

We may also specify "left" or "right" to the side argument if we only want to trim one side.

There are other times where we might want to perform the opposite of trimming, which is known as padding. Padding is useful in cases where we need to standardize a bunch of strings to a common length for further processing. The stringr function to use for padding is the str_pad() function. In order to use the str_pad() function, we have to know in advance how long we want the resulting string to be.
```{r}
str_pad("Dataquest", width = 20, side = "both", pad = " ")
" Dataquest "

```

The number width = 20 defines the length we want the output of the str_pad() function to be. The side argument helps tell str_pad() how to distribute the extra whitespace that's being added to the string, not how much whitespace to add to each side. If our width is shorter than the word we give it, then no padding will be added to the word. The pad keyword lets us specify the exact character we want to use for padding. The str_pad() function defaults to using a space.


PRACTICE

The recent_grads dataset has been loaded in. It turns out that the major_code column is formatted incorrectly and actually has leading zeroes. For example, the number "2419" should actually be "0002419". We'll use what we know now to correct this column.

1. Create a new column in recent_grads called formatted_major_code. Take the major_code column and correctly format it according to the description above.
2. A vector strings_to_trim <- c(" Apple", "Banana ", " Cherry ", " Date ") is made available to you. Clean up the strings by removing any leading and trailing whitespace. Assign the cleaned strings to the variable trimmed_strings.
```{r}
library(tidyverse)
recent_grads <- read_csv("recent_grads.csv", col_types = cols())
colnames(recent_grads) <- tolower(colnames(recent_grads))
# Add code below

# strings to trim
strings_to_trim <- c("   Apple", "Banana   ", "  Cherry  ", " Date ")
#Add code below
recent_grads <- recent_grads %>%
    mutate(
        formatted_major_code = str_pad(major_code, 7, pad = "0")
        )

trimmed_strings <- str_trim(strings_to_trim, side = "both")

```



5 of 10 · String Splitting
Learn
So far, all of the functions we dealt with have only looked at single words. However, in many cases, we'll encounter sentences with many words. Sentences are still treated as a single character vector, but there are some other operations that we can use with them. For example the following sentence:
```{r}
sentence <- "The stringr library is essential to string manipulation"

```

From R's perspective, the sentence variable just contains a single long string, but, from our human eyes, we see a sentence composed of multiple words. Fields like natural language processing often try to take these sentences and break them down into their component words. Now, instead of one long sentence, we would need a character vector where each element is an individual word. stringr provides the str_split() function for this purpose:
```{r}
library(stringr)
sentence <- "The stringr library is essential to string manipulation"
str_split(sentence, " ")

# output: 
# [[1]]
# [1] "The" "stringr" "library" "is" "essential" "to" "string"       
# [8] "manipulation."
```
The output of the str_split() function is a list. In the example above, sentence only contains one string, so the output list only contains one element: the complete sentence in a split form appearance. If we actually wanted to access this vector itself, we need to use double bracket notation, as in the following:
```{r}
str_split(sentence, " ")[[1]]

# output:
# [1] "The" "stringr" "library" "is" "essential" "to" "string"       
# [8] "manipulation."

```

From here we can access the different elements of the character vector using single bracket notation, since that's how we access things in vectors. If this gets to be a little confusing, it might be easier to assign a variable with a more helpful name to distinguish which data structure we're working with.
```{r}
# Store the first element in the str_split list
sentence_words <- str_split(sentence, " ")[[1]]

# Access elements in the vector
sentence_words[1]
# [1] "The"

sentence_words[1:3]
# [1] "The" "stringr" "library"

```

str_split() needs to be told what character it should split a sentence by, which we specify in the second input. Naturally, words are separated by whitespace, so that's what we use here (" "). We may also use "-" for things like phone numbers. By using str_split(), you can efficiently split sentences into words for various text analysis tasks.


PRACTICE
1. We provided a sentence with input_sentence. Use the str_split() function to split it into a character vector. Assign the character vector itself to the variable output1.
2. Take output1 and get the first 4 words from it. Assign these words to the variable output2.

```{r}
library(tidyverse)

input_sentence <- "You'll need to split this sentence."

output1 <- str_split(input_sentence, " ") [[1]]
output2 <- output1[1:4]

output1
output2

# output:
# [1] "You'll"    "need"      "to"        "split"     "this"      "sentence."
# [1] "You'll" "need"   "to"     "split" 

```


6 of 10 · String Concatenation
Learn
While we can split sentences into individual words, there are other times where we might want to combine multiple words into one sentence instead. We call this operation string concatenation. The str_c() function does this for us by taking in a character vector of multiple strings and returns a single-element character vector with the combined sentence.

```{r}
library(tidyverse)
words <- c("String", "concatentation", "via", "function")
str_c(words, collapse = " ")
# output:
# [1] "String concatentation via function"
```

The collapse keyword is what tells R which character to use as a separator between words while combining them into one string. Another word for this is delimiter. We use a single space " " for the collapse argument, so we can see in the resulting sentence that each of the words is separated or delimited by a single whitespace.

In general, string splitting is a much more common operation than string concatenation, but it's important to be aware of how both operations work.

PRACTICE
We provided a character vector with the input_words variable. Use the str_c() function to combine it into a single sentence. Assign this character vector itself to the variable sentence.
```{r}
library(tidyverse)

input_words <- c("This", "set", "of", "words", "should", "be", "combined")
sentence <- str_c(input_words, collapse = " ")
sentence

# output:
# [1] "This set of words should be combined"
```

7 of 10 · Regular Expression
Learn
The last few topics of this lesson involves searching strings. String search is one of the most common tasks that we can perform with strings. If you've ever used CTRL + F or Command + F to try to find a particular word in your search engine, then you have used string search.

The technical term for searching for specific strings is regular expression, or regex for short. Regular expression is a large topic as we cover later in our Regular Expressions Basics and Advanced Regular Expressionlessons, so we'll only cover the fundamental concepts needed to understand how to use some essential stringr functions.

Basically, regular expressions have two elements:
1. Text to Search Through: This is the text in which you want to search for something specific.

2. Specific Search Pattern: A search pattern is just a general term for a specific string or set of characters we want to find. When we are supplying a specific word into CTRL + F or Command + F to find a word in your search engine, we are giving it a search pattern to look for. We'll see the use of these patterns on the next two screens, so it's good to know their functions.

In general, most people use regular expression for word search, but it can be used for much more powerful purposes. Sophisticated regular expressions can be used to search and detect phone numbers, which is much harder than it sounds.



8 of 10 · String Detection
Learn
On the previous screen, we introduced the concept of regular expression which is used to search for specific patterns (words, characters, etx.) in a set of text. On this screen, we'll learn how to answer the question, "does this string contain a particular substring we are interested in?"

Take for example the following sentence:
```{r}
review <- "I really enjoyed this product, and I thought it was great for the price."

```
Let's say that we have many similar reviews like the one above and we want to try to figure out how much people like the product. Looking at the review, we can tell it has a positive sentiment because of words like "enjoyed" and "great" indicate that the user liked it. Maybe we can try to detect positive words as a way to measure how many reviews were good. To answer our question, we can use the str_detect() function.
```{r}
library(tidyverse)
review <- "I really enjoyed this product, and I thought it was great for the price."
str_detect(review, "great")

# output: TRUE
```

